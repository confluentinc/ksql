diff --git a/ksql-common/src/main/java/io/confluent/ksql/function/AggregateFunctionInitArguments.java b/ksql-common/src/main/java/io/confluent/ksql/function/AggregateFunctionInitArguments.java
index 03c27f729..9b70ecbdd 100644
--- a/ksql-common/src/main/java/io/confluent/ksql/function/AggregateFunctionInitArguments.java
+++ b/ksql-common/src/main/java/io/confluent/ksql/function/AggregateFunctionInitArguments.java
@@ -15,19 +15,11 @@
 
 package io.confluent.ksql.function;
 
-import io.confluent.ksql.name.ColumnName;
-import io.confluent.ksql.schema.ksql.ColumnRef;
 import io.confluent.ksql.util.KsqlException;
-import java.beans.Expression;
 import java.util.Arrays;
 import java.util.Collections;
 import java.util.List;
 import java.util.Objects;
-import java.util.OptionalInt;
-import java.util.stream.Collectors;
-import jdk.nashorn.internal.ir.FunctionCall;
-import org.apache.kafka.connect.data.Schema;
-import sun.tools.jstat.Literal;
 
 /**
  * Represents a list of initial arguments for the creation of a UDAF {@link
@@ -43,37 +35,6 @@ public class AggregateFunctionInitArguments {
   public static final AggregateFunctionInitArguments EMPTY_ARGS =
       new AggregateFunctionInitArguments();
 
-  public static AggregateFunctionInitArguments ofFunctionCall(final List<Expression> functionArgs,
-      final ExpressionTypeM) {
-    final Schema argumentType = expressionTypeManager.getExpressionSchema(functionArgs.get(0));
-
-    // UDAFs only support one non-constant argument, and that argument must be a column reference
-    final Expression arg = functionArgs.get(0);
-    final OptionalInt udafIndex;
-    if (arg instanceof ColumnReferenceExp) {
-      udafIndex = schema.valueColumnIndex(((ColumnReferenceExp) arg).getReference());
-    } else {
-      // assume that it is a column reference with no alias
-      udafIndex = schema.valueColumnIndex(ColumnRef.withoutSource(ColumnName.of(arg.toString())));
-    }
-
-    // args from index 1+ are all constants, such as in TopkKudaf
-    final List<Object> args = functionArgs
-        .stream()
-        .skip(1)
-        .map(expr -> {
-          if (expr instanceof Literal) {
-            return (Literal)expr;
-          } else {
-            throw new KsqlException(
-                "Aggregate function initialisation arguments must be literals"
-            );
-          }
-        })
-        .map(Literal::getValue)
-        .collect(Collectors.toList());
-  }
-
   public AggregateFunctionInitArguments(final int index, final Object... initArgs) {
     this(index, Arrays.asList(initArgs));
   }
@@ -100,6 +61,10 @@ public class AggregateFunctionInitArguments {
     return initArgs.get(i);
   }
 
+  public List<Object> args() {
+    return initArgs;
+  }
+
   public void ensureArgCount(final int expectedCount, final String functionName) {
     if (initArgs.size() != expectedCount) {
       throw new KsqlException(
diff --git a/ksql-engine/src/main/java/io/confluent/ksql/function/UdafFactoryInvoker.java b/ksql-engine/src/main/java/io/confluent/ksql/function/UdafFactoryInvoker.java
index 2644b379b..7bcb30899 100644
--- a/ksql-engine/src/main/java/io/confluent/ksql/function/UdafFactoryInvoker.java
+++ b/ksql-engine/src/main/java/io/confluent/ksql/function/UdafFactoryInvoker.java
@@ -15,7 +15,6 @@
 
 package io.confluent.ksql.function;
 
-import com.google.common.primitives.Primitives;
 import io.confluent.ksql.function.udaf.TableUdaf;
 import io.confluent.ksql.function.udaf.Udaf;
 import io.confluent.ksql.name.FunctionName;
@@ -29,7 +28,6 @@ import java.util.Objects;
 import java.util.Optional;
 import org.apache.kafka.common.metrics.Metrics;
 import org.apache.kafka.connect.data.Schema;
-import org.apache.kafka.connect.data.Struct;
 
 class UdafFactoryInvoker implements FunctionSignature {
 
@@ -75,13 +73,7 @@ class UdafFactoryInvoker implements FunctionSignature {
 
   @SuppressWarnings("unchecked")
   KsqlAggregateFunction createFunction(final AggregateFunctionInitArguments initArgs) {
-    final Object[] factoryArgs = new Object[initArgs.argsSize()];
-    for (int i = 0; i < factoryArgs.length; i++) {
-      final Class<?> argType = method.getParameterTypes()[i];
-      final Object arg = coerce(argType, initArgs.arg(i));
-      factoryArgs[i] = arg;
-    }
-
+    final Object[] factoryArgs = initArgs.args().toArray();
     try {
       final Udaf udaf = (Udaf)method.invoke(null, factoryArgs);
       final KsqlAggregateFunction function;
@@ -115,28 +107,4 @@ class UdafFactoryInvoker implements FunctionSignature {
     return false;
   }
 
-  private static Object coerce(
-      final Class<?> clazz,
-      final String arg) {
-    if (Integer.class.isAssignableFrom(Primitives.wrap(clazz))) {
-      return Integer.valueOf(arg);
-    } else if (Long.class.isAssignableFrom(Primitives.wrap(clazz))) {
-      return Long.valueOf(arg);
-    } else if (Double.class.isAssignableFrom(Primitives.wrap(clazz))) {
-      return Double.valueOf(arg);
-    } else if (Float.class.isAssignableFrom(Primitives.wrap(clazz))) {
-      return Float.valueOf(arg);
-    } else if (Byte.class.isAssignableFrom(Primitives.wrap(clazz))) {
-      return Byte.valueOf(arg);
-    } else if (Short.class.isAssignableFrom(Primitives.wrap(clazz))) {
-      return Short.valueOf(arg);
-    } else if (Boolean.class.isAssignableFrom(Primitives.wrap(clazz))) {
-      return Boolean.valueOf(arg);
-    } else if (String.class.isAssignableFrom(clazz)) {
-      return arg;
-    } else if (Struct.class.isAssignableFrom(clazz)) {
-      return arg;
-    }
-    throw new KsqlFunctionException("Unsupported udaf argument type: " + clazz);
-  }
 }
diff --git a/ksql-engine/src/main/java/io/confluent/ksql/function/udaf/topk/TopKAggregateFunctionFactory.java b/ksql-engine/src/main/java/io/confluent/ksql/function/udaf/topk/TopKAggregateFunctionFactory.java
index efb0487c0..51859c20d 100644
--- a/ksql-engine/src/main/java/io/confluent/ksql/function/udaf/topk/TopKAggregateFunctionFactory.java
+++ b/ksql-engine/src/main/java/io/confluent/ksql/function/udaf/topk/TopKAggregateFunctionFactory.java
@@ -52,7 +52,7 @@ public class TopKAggregateFunctionFactory extends AggregateFunctionFactory {
     if (argumentType.isEmpty()) {
       throw new KsqlException("TOPK function should have two arguments.");
     }
-    final int tkValFromArg = Integer.parseInt(initArgs.arg(0));
+    final int tkValFromArg = (Integer)(initArgs.arg(0));
     final Schema argSchema = argumentType.get(0);
     switch (argSchema.type()) {
       case INT32:
diff --git a/ksql-engine/src/main/java/io/confluent/ksql/function/udaf/topkdistinct/TopkDistinctAggFunctionFactory.java b/ksql-engine/src/main/java/io/confluent/ksql/function/udaf/topkdistinct/TopkDistinctAggFunctionFactory.java
index 1ede23d08..e0659f828 100644
--- a/ksql-engine/src/main/java/io/confluent/ksql/function/udaf/topkdistinct/TopkDistinctAggFunctionFactory.java
+++ b/ksql-engine/src/main/java/io/confluent/ksql/function/udaf/topkdistinct/TopkDistinctAggFunctionFactory.java
@@ -50,7 +50,7 @@ public class TopkDistinctAggFunctionFactory extends AggregateFunctionFactory {
     if (argTypeList.isEmpty()) {
       throw new KsqlException("TOPKDISTINCT function should have two arguments.");
     }
-    final int tkValFromArg = Integer.parseInt(initArgs.arg(0));
+    final int tkValFromArg = (Integer)(initArgs.arg(0));
     final Schema argSchema = argTypeList.get(0);
     switch (argSchema.type()) {
       case INT32:
diff --git a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/DoubleTopkKudafTest.java b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/DoubleTopkKudafTest.java
index f25ddd6de..aad3d6486 100644
--- a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/DoubleTopkKudafTest.java
+++ b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/DoubleTopkKudafTest.java
@@ -36,7 +36,7 @@ public class DoubleTopkKudafTest {
   private List<Schema> argumentType;
 
   private final AggregateFunctionInitArguments args =
-      new AggregateFunctionInitArguments(0, "3");
+      new AggregateFunctionInitArguments(0, 3);
 
   @Before
   public void setup() {
diff --git a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/IntTopkKudafTest.java b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/IntTopkKudafTest.java
index 88433198a..df7115322 100644
--- a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/IntTopkKudafTest.java
+++ b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/IntTopkKudafTest.java
@@ -39,7 +39,7 @@ public class IntTopkKudafTest {
   private KsqlAggregateFunction<Integer, List<Integer>, List<Integer>> topkKudaf;
 
   private AggregateFunctionInitArguments createArgs(int k) {
-    return new AggregateFunctionInitArguments(0, String.valueOf(k));
+    return new AggregateFunctionInitArguments(0, k);
   }
 
   @SuppressWarnings("unchecked")
diff --git a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/LongTopkKudafTest.java b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/LongTopkKudafTest.java
index ba9c41669..c392f60db 100644
--- a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/LongTopkKudafTest.java
+++ b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/LongTopkKudafTest.java
@@ -35,7 +35,7 @@ public class LongTopkKudafTest {
   private TopKAggregateFunctionFactory topKFactory;
   private List<Schema> argumentType;
   private final AggregateFunctionInitArguments args =
-      new AggregateFunctionInitArguments(0, "3");
+      new AggregateFunctionInitArguments(0, 3);
       
   @Before
   public void setup() {
diff --git a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/StringTopkKudafTest.java b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/StringTopkKudafTest.java
index 55027387c..35aed0ebb 100644
--- a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/StringTopkKudafTest.java
+++ b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topk/StringTopkKudafTest.java
@@ -36,7 +36,7 @@ public class StringTopkKudafTest {
   private List<Schema> argumentType;
 
   private final AggregateFunctionInitArguments args =
-      new AggregateFunctionInitArguments(0, "3");
+      new AggregateFunctionInitArguments(0, 3);
 
   @Before
   public void setup() {
diff --git a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topkdistinct/TopKDistinctTestUtils.java b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topkdistinct/TopKDistinctTestUtils.java
index 6c7f4d6b0..1b9e8f78a 100644
--- a/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topkdistinct/TopKDistinctTestUtils.java
+++ b/ksql-engine/src/test/java/io/confluent/ksql/function/udaf/topkdistinct/TopKDistinctTestUtils.java
@@ -26,6 +26,6 @@ public class TopKDistinctTestUtils {
     return (TopkDistinctKudaf<T>) new TopkDistinctAggFunctionFactory()
         .createAggregateFunction(
             Collections.singletonList(schema),
-            new AggregateFunctionInitArguments(0, String.valueOf(topk)));
+            new AggregateFunctionInitArguments(0, topk));
   }
 }
diff --git a/ksql-execution/src/main/java/io/confluent/ksql/execution/function/UdafUtil.java b/ksql-execution/src/main/java/io/confluent/ksql/execution/function/UdafUtil.java
index 46a2c8cb4..f7828a754 100644
--- a/ksql-execution/src/main/java/io/confluent/ksql/execution/function/UdafUtil.java
+++ b/ksql-execution/src/main/java/io/confluent/ksql/execution/function/UdafUtil.java
@@ -18,6 +18,7 @@ package io.confluent.ksql.execution.function;
 import io.confluent.ksql.execution.expression.tree.ColumnReferenceExp;
 import io.confluent.ksql.execution.expression.tree.Expression;
 import io.confluent.ksql.execution.expression.tree.FunctionCall;
+import io.confluent.ksql.execution.expression.tree.Literal;
 import io.confluent.ksql.execution.util.ExpressionTypeManager;
 import io.confluent.ksql.function.AggregateFunctionInitArguments;
 import io.confluent.ksql.function.FunctionRegistry;
@@ -44,11 +45,12 @@ public final class UdafUtil {
     try {
       final ExpressionTypeManager expressionTypeManager =
           new ExpressionTypeManager(schema, functionRegistry);
-      final List<Expression> functionArgs = functionCall.getArguments();
-      final Schema argumentType = expressionTypeManager.getExpressionSchema(functionArgs.get(0));
+
+      final Schema argumentType =
+          expressionTypeManager.getExpressionSchema(functionCall.getArguments().get(0));
 
       // UDAFs only support one non-constant argument, and that argument must be a column reference
-      final Expression arg = functionArgs.get(0);
+      final Expression arg = functionCall.getArguments().get(0);
       final OptionalInt udafIndex;
       if (arg instanceof ColumnReferenceExp) {
         udafIndex = schema.valueColumnIndex(((ColumnReferenceExp) arg).getReference());
@@ -56,23 +58,45 @@ public final class UdafUtil {
         // assume that it is a column reference with no alias
         udafIndex = schema.valueColumnIndex(ColumnRef.withoutSource(ColumnName.of(arg.toString())));
       }
+      if (!udafIndex.isPresent()) {
+        throw new KsqlException("Could not find column for expression: " + arg);
+      }
 
-      // args from index 1+ are all constants, such as in TopkKudaf
-      final List<String> args = functionArgs
-          .stream()
-          .map(Expression::toString)
-          .collect(Collectors.toList());
+      final AggregateFunctionInitArguments aggregateFunctionInitArguments =
+          createAggregateFunctionInitArgs(udafIndex.getAsInt(), functionCall);
 
       return functionRegistry.getAggregateFunction(
           functionCall.getName().name(),
           argumentType,
-          AggregateFunctionInitArguments.ofFunctionArgs(
-              udafIndex.orElseThrow(
-                  () -> new KsqlException("Could not find column for expression: " + arg)),
-              args)
+          aggregateFunctionInitArguments
       );
     } catch (final Exception e) {
       throw new KsqlException("Failed to create aggregate function: " + functionCall, e);
     }
   }
+
+  public static AggregateFunctionInitArguments createAggregateFunctionInitArgs(
+      final int udafIndex,
+      final FunctionCall functionCall
+  ) {
+    // args from index > 0 are all literals
+    final List<Object> args = functionCall.getArguments()
+        .stream()
+        .skip(1)
+        .map(expr -> {
+          if (expr instanceof Literal) {
+            return (Literal)expr;
+          } else {
+            throw new KsqlException(
+                "Aggregate function initialisation arguments must be literals"
+            );
+          }
+        })
+        .map(Literal::getValue)
+        .collect(Collectors.toList());
+
+    return new AggregateFunctionInitArguments(udafIndex, args);
+  }
+
+
 }
diff --git a/ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java b/ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java
index e885712db..c0c0fcc5a 100644
--- a/ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java
+++ b/ksql-execution/src/main/java/io/confluent/ksql/execution/util/ExpressionTypeManager.java
@@ -46,6 +46,7 @@ import io.confluent.ksql.execution.expression.tree.TimeLiteral;
 import io.confluent.ksql.execution.expression.tree.TimestampLiteral;
 import io.confluent.ksql.execution.expression.tree.Type;
 import io.confluent.ksql.execution.expression.tree.WhenClause;
+import io.confluent.ksql.execution.function.UdafUtil;
 import io.confluent.ksql.execution.function.udf.structfieldextractor.FetchFieldFromStruct;
 import io.confluent.ksql.function.AggregateFunctionInitArguments;
 import io.confluent.ksql.function.FunctionRegistry;
@@ -66,7 +67,6 @@ import java.util.ArrayList;
 import java.util.List;
 import java.util.Objects;
 import java.util.Optional;
-import java.util.stream.Collectors;
 import org.apache.kafka.connect.data.Schema;
 
 @SuppressWarnings("deprecation") // Need to migrate away from Connect Schema use.
@@ -364,10 +364,8 @@ public class ExpressionTypeManager {
             ? FunctionRegistry.DEFAULT_FUNCTION_ARG_SCHEMA
             : getExpressionSchema(node.getArguments().get(0));
 
-        final List<String> sargs =
-            node.getArguments().stream().map(Object::toString).collect(Collectors.toList());
         final AggregateFunctionInitArguments args =
-            AggregateFunctionInitArguments.ofFunctionArgs(0, sargs);
+            UdafUtil.createAggregateFunctionInitArgs(0, node);
 
         final KsqlAggregateFunction aggFunc = functionRegistry
             .getAggregateFunction(node.getName().name(), schema, args);
