<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ksqldb_confluent.client API documentation</title>
<meta name="description" content="" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ksqldb_confluent.client</code></h1>
</header>
<section id="section-intro">
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python"># Copyright 2022 Confluent Inc.
#
# Licensed under the Apache License, Version 2.0 (the &#34;License&#34;);
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
# http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an &#34;AS IS&#34; BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# Refer to LICENSE for more information.

import asyncio
from asyncio import Future, Queue
from typing import List

import httpx
from httpx import URL, Headers, BasicAuth

from ksqldb_confluent.exceptions import KsqlDbClientException
from ksqldb_confluent.batched_query_result import BatchedQueryResult
from ksqldb_confluent.row import Row
from ksqldb_confluent.__schema_parser import SchemaParser
from ksqldb_confluent.streamed_query_result import StreamedQueryResult
from ksqldb_confluent.__streamed_row import StreamedRow
from ksqldb_confluent.types.schema import Schema
from ksqldb_confluent.__utils import _canonicalize_json_string
from ksqldb_confluent.__utils import get_client_version


async def _handle_streamed_row(
        streamed_row: StreamedRow,
        row_queue: Queue,
        completion_source: Future):
    if streamed_row.header:
        schema_str: str = streamed_row.header.schema
        try:
            schema: Schema = SchemaParser(schema_str).parse_schema()
        except Exception:
            schema = None
        result: StreamedQueryResult = \
            StreamedQueryResult(streamed_row.header.query_id, schema, row_queue)
        completion_source.set_result(result)
    elif streamed_row.row:
        if streamed_row.row.tombstone:
            await row_queue.put(Row([]))
        else:
            await row_queue.put((Row(streamed_row.row.columns)))
    else:
        raise KsqlDbClientException(&#39;Received response line of unknown type.&#39;)


class Client:
    &#34;&#34;&#34;
    A client object for issuing commands to ksqlDB.
    &#34;&#34;&#34;
    _header_accept: str = &#39;Accept&#39;
    _header_user_agent: str = &#39;User-agent&#39;
    _user_agent_name: str = &#39;ksqlDB Python Client&#39;

    def __init__(self,
                 host: str,
                 port: int,
                 api_key: str = &#39;&#39;,
                 secret: str = &#39;&#39;,
                 use_tls: bool = False,
                 timeout: float = None):
        &#34;&#34;&#34;
        Constructor for the client.

        Args:
            host: The host of the ksqlDB server
            port: The port of the ksqlDB server. Usually 8088
            api_key: The api_key to authenticate with the ksqlDB server
            secret: The secret to authenticate with the ksqlDB server
            use_tls: use TLS or not
            timeout: timeout in seconds
        &#34;&#34;&#34;
        self.host = host
        self.port = port
        self.scheme = &#39;https&#39; if use_tls else &#39;http&#39;
        self.api_key = api_key
        self.secret = secret
        self.timeout = timeout

        self.client = httpx.AsyncClient(
            http1=False,
            http2=True,
            timeout=self.timeout)

    async def execute_query_async(self, sql: str, timeout: float = None) -&gt; BatchedQueryResult:
        &#34;&#34;&#34;
        Executes a query. Note that this is limited to pull and push queries and does not cover
        other statement type commands.

        Also, this is appropriate for queries which can run to completion in a batch, namely pull
        queries and push queries with limit statements. Push queries without limit statements will
        never complete.

        Args:
            sql: The sql query to run
            timeout: timeout in seconds

        Returns:
            BatchedQueryResult: Contains the results from the query executed
        &#34;&#34;&#34;
        streamed_query_result: StreamedQueryResult = await self.stream_query_async(sql, timeout)
        query_id: str = streamed_query_result.query_id
        schema: Schema = streamed_query_result.schema
        rows: List[Row] = []
        row = await streamed_query_result.row_queue.get()
        while row is not None:
            rows.append(row)
            row = await streamed_query_result.row_queue.get()
        return BatchedQueryResult(query_id=query_id, schema=schema, rows=rows)

    async def stream_query_async(self, sql: str, timeout: float = None) -&gt; StreamedQueryResult:
        &#34;&#34;&#34;
        Executes a query. Note that this is limited to pull and push queries and does not cover
        other statement type commands. This is appropriate for queries which may not run to
        immediate completion, so this works well for both pull and push queries.

        Args:
            sql: The sql query to run
            timeout: timeout in seconds

        Returns:
            StreamedQueryResult: Contains the results from the query executed
        &#34;&#34;&#34;
        # The Future that indicates if the query result is available or not.
        # The Future will be set once we receive the Header of the query response.
        completion_source: Future = asyncio.Future()
        asyncio.create_task(self._execute_request(sql, completion_source, timeout))
        await completion_source
        return completion_source.result()

    # Executes the given sql
    async def _execute_request(self,
                               sql: str,
                               completion_source: Future,
                               timeout: float = None):
        # Build the URL we&#39;ll use for the request.
        path: str = &#39;query-stream&#39;
        url: URL = URL(f&#34;{self.scheme}://{self.host}:{self.port}/{path}&#34;)

        # Construct the request
        data: dict = {&#39;sql&#39;: sql}
        headers: dict = {
            self._header_accept: &#39;application/vnd.ksql.v1+json&#39;,
            self._header_user_agent: f&#39;{Client._user_agent_name} v{get_client_version()}&#39;
        }

        # Construct the auth
        auth: BasicAuth = BasicAuth(self.api_key, self.secret)

        try:
            # Issue the request and handle the response
            async with self.client.stream(method=&#39;POST&#39;, url=url, headers=Headers(headers),
                                          json=data, auth=auth, timeout=timeout) as response:
                try:
                    response.raise_for_status()
                except httpx.RequestError as ex:
                    return completion_source.set_exception(KsqlDbClientException(
                        f&#34;An error occurred while requesting {ex.request.url!r}.&#34;))
                except httpx.HTTPStatusError as ex:
                    return completion_source.set_exception(
                        KsqlDbClientException(f&#34;Error response {ex.response.status_code} &#34;
                                              f&#34;while requesting {ex.request.url!r}.&#34;))

                # Construct the queue that will hold the rows
                row_queue: Queue = Queue()
                async for row in response.aiter_lines():
                    streamed_row: StreamedRow = \
                        StreamedRow.from_json(_canonicalize_json_string(row))
                    if streamed_row.header or streamed_row.row:
                        await _handle_streamed_row(streamed_row, row_queue, completion_source)

                # Add sentinel None after adding all rows to indicate the end
                await row_queue.put(None)
        except Exception as ex:
            exception: KsqlDbClientException = KsqlDbClientException(&#39;Unexpected Client Error&#39;,
                                                                     KsqlDbClientException(str(ex)))
            if completion_source.done():
                result: StreamedQueryResult = completion_source.result()
                result.status.set_exception(exception)
            return completion_source.set_exception(exception)

    async def close(self):
        &#34;&#34;&#34;
        Closes the client and disposes of any resources that it uses,
        including the underlying HttpClient and its resources.
        &#34;&#34;&#34;
        await self.client.aclose()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-classes">Classes</h2>
<dl>
<dt id="ksqldb_confluent.client.Client"><code class="flex name class">
<span>class <span class="ident">Client</span></span>
<span>(</span><span>host: str, port: int, api_key: str = '', secret: str = '', use_tls: bool = False, timeout: float = None)</span>
</code></dt>
<dd>
<div class="desc"><p>A client object for issuing commands to ksqlDB.</p>
<p>Constructor for the client.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>host</code></strong></dt>
<dd>The host of the ksqlDB server</dd>
<dt><strong><code>port</code></strong></dt>
<dd>The port of the ksqlDB server. Usually 8088</dd>
<dt><strong><code>api_key</code></strong></dt>
<dd>The api_key to authenticate with the ksqlDB server</dd>
<dt><strong><code>secret</code></strong></dt>
<dd>The secret to authenticate with the ksqlDB server</dd>
<dt><strong><code>use_tls</code></strong></dt>
<dd>use TLS or not</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout in seconds</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">class Client:
    &#34;&#34;&#34;
    A client object for issuing commands to ksqlDB.
    &#34;&#34;&#34;
    _header_accept: str = &#39;Accept&#39;
    _header_user_agent: str = &#39;User-agent&#39;
    _user_agent_name: str = &#39;ksqlDB Python Client&#39;

    def __init__(self,
                 host: str,
                 port: int,
                 api_key: str = &#39;&#39;,
                 secret: str = &#39;&#39;,
                 use_tls: bool = False,
                 timeout: float = None):
        &#34;&#34;&#34;
        Constructor for the client.

        Args:
            host: The host of the ksqlDB server
            port: The port of the ksqlDB server. Usually 8088
            api_key: The api_key to authenticate with the ksqlDB server
            secret: The secret to authenticate with the ksqlDB server
            use_tls: use TLS or not
            timeout: timeout in seconds
        &#34;&#34;&#34;
        self.host = host
        self.port = port
        self.scheme = &#39;https&#39; if use_tls else &#39;http&#39;
        self.api_key = api_key
        self.secret = secret
        self.timeout = timeout

        self.client = httpx.AsyncClient(
            http1=False,
            http2=True,
            timeout=self.timeout)

    async def execute_query_async(self, sql: str, timeout: float = None) -&gt; BatchedQueryResult:
        &#34;&#34;&#34;
        Executes a query. Note that this is limited to pull and push queries and does not cover
        other statement type commands.

        Also, this is appropriate for queries which can run to completion in a batch, namely pull
        queries and push queries with limit statements. Push queries without limit statements will
        never complete.

        Args:
            sql: The sql query to run
            timeout: timeout in seconds

        Returns:
            BatchedQueryResult: Contains the results from the query executed
        &#34;&#34;&#34;
        streamed_query_result: StreamedQueryResult = await self.stream_query_async(sql, timeout)
        query_id: str = streamed_query_result.query_id
        schema: Schema = streamed_query_result.schema
        rows: List[Row] = []
        row = await streamed_query_result.row_queue.get()
        while row is not None:
            rows.append(row)
            row = await streamed_query_result.row_queue.get()
        return BatchedQueryResult(query_id=query_id, schema=schema, rows=rows)

    async def stream_query_async(self, sql: str, timeout: float = None) -&gt; StreamedQueryResult:
        &#34;&#34;&#34;
        Executes a query. Note that this is limited to pull and push queries and does not cover
        other statement type commands. This is appropriate for queries which may not run to
        immediate completion, so this works well for both pull and push queries.

        Args:
            sql: The sql query to run
            timeout: timeout in seconds

        Returns:
            StreamedQueryResult: Contains the results from the query executed
        &#34;&#34;&#34;
        # The Future that indicates if the query result is available or not.
        # The Future will be set once we receive the Header of the query response.
        completion_source: Future = asyncio.Future()
        asyncio.create_task(self._execute_request(sql, completion_source, timeout))
        await completion_source
        return completion_source.result()

    # Executes the given sql
    async def _execute_request(self,
                               sql: str,
                               completion_source: Future,
                               timeout: float = None):
        # Build the URL we&#39;ll use for the request.
        path: str = &#39;query-stream&#39;
        url: URL = URL(f&#34;{self.scheme}://{self.host}:{self.port}/{path}&#34;)

        # Construct the request
        data: dict = {&#39;sql&#39;: sql}
        headers: dict = {
            self._header_accept: &#39;application/vnd.ksql.v1+json&#39;,
            self._header_user_agent: f&#39;{Client._user_agent_name} v{get_client_version()}&#39;
        }

        # Construct the auth
        auth: BasicAuth = BasicAuth(self.api_key, self.secret)

        try:
            # Issue the request and handle the response
            async with self.client.stream(method=&#39;POST&#39;, url=url, headers=Headers(headers),
                                          json=data, auth=auth, timeout=timeout) as response:
                try:
                    response.raise_for_status()
                except httpx.RequestError as ex:
                    return completion_source.set_exception(KsqlDbClientException(
                        f&#34;An error occurred while requesting {ex.request.url!r}.&#34;))
                except httpx.HTTPStatusError as ex:
                    return completion_source.set_exception(
                        KsqlDbClientException(f&#34;Error response {ex.response.status_code} &#34;
                                              f&#34;while requesting {ex.request.url!r}.&#34;))

                # Construct the queue that will hold the rows
                row_queue: Queue = Queue()
                async for row in response.aiter_lines():
                    streamed_row: StreamedRow = \
                        StreamedRow.from_json(_canonicalize_json_string(row))
                    if streamed_row.header or streamed_row.row:
                        await _handle_streamed_row(streamed_row, row_queue, completion_source)

                # Add sentinel None after adding all rows to indicate the end
                await row_queue.put(None)
        except Exception as ex:
            exception: KsqlDbClientException = KsqlDbClientException(&#39;Unexpected Client Error&#39;,
                                                                     KsqlDbClientException(str(ex)))
            if completion_source.done():
                result: StreamedQueryResult = completion_source.result()
                result.status.set_exception(exception)
            return completion_source.set_exception(exception)

    async def close(self):
        &#34;&#34;&#34;
        Closes the client and disposes of any resources that it uses,
        including the underlying HttpClient and its resources.
        &#34;&#34;&#34;
        await self.client.aclose()</code></pre>
</details>
<h3>Methods</h3>
<dl>
<dt id="ksqldb_confluent.client.Client.close"><code class="name flex">
<span>async def <span class="ident">close</span></span>(<span>self)</span>
</code></dt>
<dd>
<div class="desc"><p>Closes the client and disposes of any resources that it uses,
including the underlying HttpClient and its resources.</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def close(self):
    &#34;&#34;&#34;
    Closes the client and disposes of any resources that it uses,
    including the underlying HttpClient and its resources.
    &#34;&#34;&#34;
    await self.client.aclose()</code></pre>
</details>
</dd>
<dt id="ksqldb_confluent.client.Client.execute_query_async"><code class="name flex">
<span>async def <span class="ident">execute_query_async</span></span>(<span>self, sql: str, timeout: float = None) ‑> <a title="ksqldb_confluent.batched_query_result.BatchedQueryResult" href="batched_query_result.html#ksqldb_confluent.batched_query_result.BatchedQueryResult">BatchedQueryResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Executes a query. Note that this is limited to pull and push queries and does not cover
other statement type commands.</p>
<p>Also, this is appropriate for queries which can run to completion in a batch, namely pull
queries and push queries with limit statements. Push queries without limit statements will
never complete.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sql</code></strong></dt>
<dd>The sql query to run</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>BatchedQueryResult</code></dt>
<dd>Contains the results from the query executed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def execute_query_async(self, sql: str, timeout: float = None) -&gt; BatchedQueryResult:
    &#34;&#34;&#34;
    Executes a query. Note that this is limited to pull and push queries and does not cover
    other statement type commands.

    Also, this is appropriate for queries which can run to completion in a batch, namely pull
    queries and push queries with limit statements. Push queries without limit statements will
    never complete.

    Args:
        sql: The sql query to run
        timeout: timeout in seconds

    Returns:
        BatchedQueryResult: Contains the results from the query executed
    &#34;&#34;&#34;
    streamed_query_result: StreamedQueryResult = await self.stream_query_async(sql, timeout)
    query_id: str = streamed_query_result.query_id
    schema: Schema = streamed_query_result.schema
    rows: List[Row] = []
    row = await streamed_query_result.row_queue.get()
    while row is not None:
        rows.append(row)
        row = await streamed_query_result.row_queue.get()
    return BatchedQueryResult(query_id=query_id, schema=schema, rows=rows)</code></pre>
</details>
</dd>
<dt id="ksqldb_confluent.client.Client.stream_query_async"><code class="name flex">
<span>async def <span class="ident">stream_query_async</span></span>(<span>self, sql: str, timeout: float = None) ‑> <a title="ksqldb_confluent.streamed_query_result.StreamedQueryResult" href="streamed_query_result.html#ksqldb_confluent.streamed_query_result.StreamedQueryResult">StreamedQueryResult</a></span>
</code></dt>
<dd>
<div class="desc"><p>Executes a query. Note that this is limited to pull and push queries and does not cover
other statement type commands. This is appropriate for queries which may not run to
immediate completion, so this works well for both pull and push queries.</p>
<h2 id="args">Args</h2>
<dl>
<dt><strong><code>sql</code></strong></dt>
<dd>The sql query to run</dd>
<dt><strong><code>timeout</code></strong></dt>
<dd>timeout in seconds</dd>
</dl>
<h2 id="returns">Returns</h2>
<dl>
<dt><code>StreamedQueryResult</code></dt>
<dd>Contains the results from the query executed</dd>
</dl></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">async def stream_query_async(self, sql: str, timeout: float = None) -&gt; StreamedQueryResult:
    &#34;&#34;&#34;
    Executes a query. Note that this is limited to pull and push queries and does not cover
    other statement type commands. This is appropriate for queries which may not run to
    immediate completion, so this works well for both pull and push queries.

    Args:
        sql: The sql query to run
        timeout: timeout in seconds

    Returns:
        StreamedQueryResult: Contains the results from the query executed
    &#34;&#34;&#34;
    # The Future that indicates if the query result is available or not.
    # The Future will be set once we receive the Header of the query response.
    completion_source: Future = asyncio.Future()
    asyncio.create_task(self._execute_request(sql, completion_source, timeout))
    await completion_source
    return completion_source.result()</code></pre>
</details>
</dd>
</dl>
</dd>
</dl>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ksqldb_confluent" href="index.html">ksqldb_confluent</a></code></li>
</ul>
</li>
<li><h3><a href="#header-classes">Classes</a></h3>
<ul>
<li>
<h4><code><a title="ksqldb_confluent.client.Client" href="#ksqldb_confluent.client.Client">Client</a></code></h4>
<ul class="">
<li><code><a title="ksqldb_confluent.client.Client.close" href="#ksqldb_confluent.client.Client.close">close</a></code></li>
<li><code><a title="ksqldb_confluent.client.Client.execute_query_async" href="#ksqldb_confluent.client.Client.execute_query_async">execute_query_async</a></code></li>
<li><code><a title="ksqldb_confluent.client.Client.stream_query_async" href="#ksqldb_confluent.client.Client.stream_query_async">stream_query_async</a></code></li>
</ul>
</li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>