{
  "comments": [
    "Tests covering use of the GROUP BY clause"
  ],
  "tests": [
    {
      "name": "only key column (stream->table)",
      "statements": [
        "CREATE STREAM INPUT (ID INT KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;"
      ],
      "inputs": [
        {"topic": "test_topic", "timestamp": 12345, "key": 11, "value": {}},
        {"topic": "test_topic", "timestamp": 12365, "key": 10, "value": {}},
        {"topic": "test_topic", "timestamp": 12375, "key": 11, "value": {}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "timestamp": 12345, "key": 11, "value": {"ID": 11, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "timestamp": 12365, "key": 10, "value": {"ID": 10, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "timestamp": 12375, "key": 11, "value": {"ID": 11, "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "OUTPUT", "key": 11, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 10, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 11, "value": {"COUNT": 2}}
      ],
      "post": {
        "topics": {
          "blacklist": ".*-repartition"
        },
        "sources": [
          {
            "name": "OUTPUT",
            "type": "table",
            "keyFormat": {"format": "KAFKA"},
            "schema": "ID INT KEY, COUNT BIGINT"
          }
        ]
      }
    },
    {
      "name": "udafs only in having (stream->table)",
      "statements": [
        "CREATE STREAM INPUT (NAME STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT NAME, LEN(NAME) AS LEN FROM INPUT GROUP BY NAME HAVING COUNT(NAME) = 2;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"NAME": "bob"}},
        {"topic": "test_topic", "value": {"NAME": "bob"}},
        {"topic": "test_topic", "value": {"NAME": "bob"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "bob", "value": null},
        {"topic": "OUTPUT", "key": "bob", "value": {"LEN": 3}},
        {"topic": "OUTPUT", "key": "bob", "value": null}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "keyFormat": {"format": "KAFKA"}, "schema": "NAME STRING KEY, LEN INT"}
        ]
      }
    },
    {
      "name": "all columns - repartition (stream->table)",
      "comment": "Currently, at least one value column is required...",
      "statements": [
        "CREATE STREAM INPUT (NAME STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT NAME FROM INPUT GROUP BY NAME HAVING COUNT(NAME) = 1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The projection contains no value columns."
      }
    },
    {
      "name": "all columns - no repartition (stream->table)",
      "comment": "Currently, at least one value column is required...",
      "statements": [
        "CREATE STREAM INPUT (NAME STRING KEY, V0 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT NAME FROM INPUT GROUP BY NAME HAVING COUNT(NAME) = 1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The projection contains no value columns."
      }
    },
    {
      "name": "value column (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 3}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA STRING KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "struct field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, ADDRESS STRUCT<STREET STRING, TOWN STRING>) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ADDRESS->TOWN, COUNT(*) AS COUNT FROM TEST GROUP BY ADDRESS->TOWN;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "Oxford"}}},
        {"topic": "test_topic", "key": 1, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "London"}}},
        {"topic": "test_topic", "key": 2, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "Oxford"}}},
        {"topic": "test_topic", "key": 3, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "London"}}},
        {"topic": "test_topic", "key": 4, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "Oxford"}}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "Oxford", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "Oxford"}}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "London", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "London"}}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "Oxford", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "Oxford"}}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "London", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "London"}}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "Oxford", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "Oxford"}}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "Oxford", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "Oxford"}, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "London", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "London"}, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "Oxford", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "Oxford"}, "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "London", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "London"}, "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "Oxford", "value": {"ROWTIME": 0, "ADDRESS": {"STREET": "1st Steet", "TOWN": "Oxford"}, "KSQL_AGG_VARIABLE_0": 3}},
        {"topic": "OUTPUT", "key": "Oxford", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "London", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "Oxford", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "London", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "Oxford", "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "TOWN STRING KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, DATA STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT LEN(DATA), COUNT(*) AS COUNT FROM TEST GROUP BY LEN(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "22"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "333"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "-2"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "003"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "2-"}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": {"ROWTIME": 0, "DATA": "22"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 3, "value": {"ROWTIME": 0, "DATA": "333"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": {"ROWTIME": 0, "DATA": "-2"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 3, "value": {"ROWTIME": 0, "DATA": "003"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": {"ROWTIME": 0, "DATA": "2-"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ROWTIME": 0, "DATA": "22", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 3, "value": {"ROWTIME": 0, "DATA": "333", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ROWTIME": 0, "DATA": "-2", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 3, "value": {"ROWTIME": 0, "DATA": "003", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ROWTIME": 0, "DATA": "2-", "KSQL_AGG_VARIABLE_0": 3}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 INT KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single column with alias (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA AS NEW_KEY, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 3}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY STRING KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single column with alias (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA AS NEW_KEY, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"ROWTIME": 0, "DATA": "d2", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 0, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 3}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY STRING KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single expression with alias (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT LEN(DATA) AS NEW_KEY, COUNT(*) AS COUNT FROM TEST GROUP BY LEN(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "22"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "333"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "-2"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "003"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "2-"}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": {"ROWTIME": 0, "DATA": "22"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 3, "value": {"ROWTIME": 0, "DATA": "333"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": {"ROWTIME": 0, "DATA": "-2"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 3, "value": {"ROWTIME": 0, "DATA": "003"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": {"ROWTIME": 0, "DATA": "2-"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ROWTIME": 0, "DATA": "22", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 3, "value": {"ROWTIME": 0, "DATA": "333", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ROWTIME": 0, "DATA": "-2", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 3, "value": {"ROWTIME": 0, "DATA": "003", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ROWTIME": 0, "DATA": "2-", "KSQL_AGG_VARIABLE_0": 3}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY INT KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single expression with alias (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT LEN(DATA) AS NEW_KEY, COUNT(*) AS COUNT FROM TEST GROUP BY LEN(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "22"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "333"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "-2"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "003"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "2-"}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": {"ROWTIME": 0, "DATA": "22"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 3, "value": {"ROWTIME": 0, "DATA": "333"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": {"ROWTIME": 0, "DATA": "-2"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 3, "value": {"ROWTIME": 0, "DATA": "003"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": {"ROWTIME": 0, "DATA": "2-"}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ROWTIME": 0, "DATA": "22", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 3, "value": {"ROWTIME": 0, "DATA": "333", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ROWTIME": 0, "DATA": "-2", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 3, "value": {"ROWTIME": 0, "DATA": "003", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ROWTIME": 0, "DATA": "2-", "KSQL_AGG_VARIABLE_0": 3}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY INT KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "steam with no key",
      "statements": [
        "CREATE STREAM TEST (data INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"data": 22}},
        {"topic": "test_topic", "value": {"data": 333}},
        {"topic": "test_topic", "value": {"data": 22}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 22, "value": {"ROWTIME": 0, "DATA": 22}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 333, "value": {"ROWTIME": 0, "DATA": 333}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 22, "value": {"ROWTIME": 0, "DATA": 22}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 22, "value": {"ROWTIME": 0, "DATA": 22, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 333, "value": {"ROWTIME": 0, "DATA": 333, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 22, "value": {"ROWTIME": 0, "DATA": 22, "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "OUTPUT", "key": 22, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 333, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 22, "value": {"COUNT": 2}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA INT KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "subscript in group-by and select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, VARCHAR>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo'] AS NEW_KEY, COUNT(*) AS COUNT FROM INPUT GROUP BY col1['foo'];"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"foo" : "lala"}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"foo" : "kaka"}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"alice" : "wonderland"}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"mary" : "lamb"}}},
        {"topic": "test_topic", "key": 4, "value": {"col1": null}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "lala", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "kaka", "value": {"COUNT": 1}}
      ]
    },
    {
      "name": "subscript in group-by and having",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, VARCHAR>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo'] AS NEW_KEY, COUNT(*) AS COUNT FROM INPUT GROUP BY col1['foo'] HAVING col1['foo']='lala';"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"foo" : "lala"}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"foo" : "kaka"}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"alice" : "wonderland"}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"mary" : "lamb"}}},
        {"topic": "test_topic", "key": 4, "value": {"col1": null}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "lala", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "kaka", "value": null}
      ]
    },
    {
      "name": "subscript in group-by and non aggregate function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, VARCHAR>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo'] AS NEW_KEY, AS_VALUE(col1['foo']) as VV, COUNT(*) AS COUNT FROM INPUT GROUP BY col1['foo'];"

      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"foo" : "lala"}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"foo" : "kaka"}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"alice" : "wonderland"}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"mary" : "lamb"}}},
        {"topic": "test_topic", "key": 4, "value": {"col1": null}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "lala", "value": {"VV": "lala","COUNT": 1}},
        {"topic": "OUTPUT", "key": "kaka", "value": {"VV": "kaka","COUNT": 1}}
      ]
    },
    {
      "name": "struct in group-by and non aggregate function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 STRUCT<a VARCHAR, b INT>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1->a AS NEW_KEY, AS_VALUE(col1->a) as VV, COUNT(*) AS COUNT FROM INPUT GROUP BY col1->a;"

      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"a" : "lala", "b": 1}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"a" : "lala", "b":  2}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"a" : "wonderland", "b": 3}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"a" : "lamb", "b": 4}}},
        {"topic": "test_topic", "key": 4, "value": {"col1": null}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "lala", "value": {"VV": "lala","COUNT": 1}},
        {"topic": "OUTPUT", "key": "lala", "value": {"VV": "lala","COUNT": 2}},
        {"topic": "OUTPUT", "key": "wonderland", "value": {"VV": "wonderland","COUNT": 1}},
        {"topic": "OUTPUT", "key": "lamb", "value": {"VV": "lamb","COUNT": 1}}
      ]
    },
    {
      "name": "function in group-by and nested function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 VARCHAR, col2 VARCHAR, col3 VARCHAR) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT INITCAP(COL1) AS G1, COL2 AS G2, TRIM(COL3) AS G3, concat(initcap(col1), col2, trim(col3)) AS foo, COUNT(*) FROM input GROUP BY INITCAP(col1), col2, TRIM(col3);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": "smells", "col2": "like", "col3": "teen spirit"}},
        {"topic": "test_topic", "key": 1, "value": {"col1": "the", "col2": "man who", "col3": "stole the world"}},
        {"topic": "test_topic", "key": 2, "value": {"col1": "smells", "col2": "like", "col3": "spring"}},
        {"topic": "test_topic", "key": 3, "value": {"col1": "smells", "col2": "like", "col3": "   teen spirit   "}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "Smells|+|like|+|teen spirit", "value": {"FOO": "Smellsliketeen spirit", "KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "The|+|man who|+|stole the world", "value": {"FOO": "Theman whostole the world", "KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "Smells|+|like|+|spring", "value": {"FOO": "Smellslikespring","KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "Smells|+|like|+|teen spirit", "value": {"FOO": "Smellsliketeen spirit","KSQL_COL_0": 2}}
      ]
    },
    {
      "name": "group by column in nested non-aggregate function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 VARCHAR, col2 VARCHAR, col3 VARCHAR) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT INITCAP(COL1) AS G1, COL2 AS G2, COL3 AS G3, concat(initcap(col1), col2, trim(col3)) AS foo, COUNT(*) FROM input GROUP BY INITCAP(col1), col2, col3;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": "smells", "col2": "like", "col3": "teen spirit"}},
        {"topic": "test_topic", "key": 1, "value": {"col1": "the", "col2": "man who", "col3": "stole the world"}},
        {"topic": "test_topic", "key": 2, "value": {"col1": "smells", "col2": "like", "col3": "spring"}},
        {"topic": "test_topic", "key": 3, "value": {"col1": "smells", "col2": "like", "col3": "   teen spirit   "}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "Smells|+|like|+|teen spirit", "value": {"FOO": "Smellsliketeen spirit", "KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "The|+|man who|+|stole the world", "value": {"FOO": "Theman whostole the world", "KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "Smells|+|like|+|spring", "value": {"FOO": "Smellslikespring","KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "Smells|+|like|+|   teen spirit   ", "value": {"FOO": "Smellsliketeen spirit","KSQL_COL_0": 1}}
      ]
    },
    {
      "name": "function group by column used in non-aggregate function in having",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 VARCHAR, col2 VARCHAR, col3 VARCHAR) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT INITCAP(COL1) AS G1, COL2 AS G2, trim(COL3) AS G3, COUNT(*) FROM input GROUP BY INITCAP(col1), col2, trim(col3) HAVING substring(trim(col3),1,4) = 'teen';"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": "smells", "col2": "like", "col3": "teen spirit"}},
        {"topic": "test_topic", "key": 1, "value": {"col1": "the", "col2": "man who", "col3": "stole the world"}},
        {"topic": "test_topic", "key": 2, "value": {"col1": "smells", "col2": "like", "col3": "spring"}},
        {"topic": "test_topic", "key": 3, "value": {"col1": "smells", "col2": "like", "col3": "   teen spirit   "}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "Smells|+|like|+|teen spirit", "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "The|+|man who|+|stole the world", "value": null},
        {"topic": "OUTPUT", "key": "Smells|+|like|+|spring", "value": null},
        {"topic": "OUTPUT", "key": "Smells|+|like|+|teen spirit", "value": {"KSQL_COL_0": 2}}
      ]
    },
    {
      "name": "arithmetic in group by column used in non-aggregate function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 INT, col2 INT) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1+col2 AS G1, AS_VALUE(col1+col2), COUNT(*) FROM input GROUP BY col1+col2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": 1, "col2": 1}},
        {"topic": "test_topic", "key": 1, "value": {"col1": 2, "col2": 2}},
        {"topic": "test_topic", "key": 2, "value": {"col1": 3, "col2": 3}},
        {"topic": "test_topic", "key": 3, "value": {"col1": 4, "col2": 4}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": {"KSQL_COL_0": 2, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": 4, "value": {"KSQL_COL_0": 4, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": 6, "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": 8, "value": {"KSQL_COL_0": 8, "KSQL_COL_1": 1}}
      ]
    },
    {
      "name": "expressions used in non-aggregate function in select whose children are not part of group-by",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, INT>, col2 MAP<VARCHAR, INT>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo']+col2['bar'] AS G1, AS_VALUE(col1['foo']+col2['bar']), COUNT(*) FROM input GROUP BY col1['foo']+col2['bar'];"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"a" : 1}, "col2": {"b" : 1}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"foo" : 1}, "col2": {"bar" : 1}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"bar" : 1}, "col2": {"foo" : 1}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"foo" : 1}, "col2": {"foo" : 1}}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": {"KSQL_COL_0": 2, "KSQL_COL_1": 1}}
      ]
    },
    {
      "name": "unknown function",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, WONT_FIND_ME(ID) FROM TEST GROUP BY DATA;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Can't find any functions with the name 'WONT_FIND_ME'"
      }
    },
    {
      "name": "non-table udaf on table",
      "statements": [
        "CREATE TABLE INPUT (ID BIGINT PRIMARY KEY, F0 INT, F1 BIGINT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ID, LATEST_BY_OFFSET(F0), MIN(F1), MAX(F1) FROM INPUT GROUP BY ID;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The aggregation functions LATEST_BY_OFFSET, MIN and MAX cannot be applied to a table source, only to a stream source."
      }
    },
    {
      "name": "multiple expressions",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT f2, f1, f2+f1, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "1|+|2", "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": "2|+|4", "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": "1|+|2", "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": "2|+|4", "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": "2|+|1", "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_2 STRING KEY, KSQL_COL_0 INT, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "single expression - key in projection more than once",
      "statements": [
        "CREATE STREAM INPUT (ID INT KEY, NAME STRING) WITH (kafka_topic='input',value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT NAME, NAME AS NAME2, COUNT(1) FROM INPUT GROUP BY NAME;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The projection contains a key column more than once: `NAME` and `NAME2`."
      }
    },
    {
      "name": "single expression - key missing from projection - with other column of same name",
      "statements": [
        "CREATE STREAM INPUT (ID INT KEY, NAME STRING) WITH (kafka_topic='input',value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(1) AS NAME FROM INPUT GROUP BY NAME;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The query used to build `OUTPUT` must include the grouping expression NAME in its projection."
      }
    },
    {
      "name": "single expression - key missing from projection",
      "statements": [
        "CREATE STREAM INPUT (ID INT KEY, NAME STRING) WITH (kafka_topic='input',value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(1) FROM INPUT GROUP BY NAME;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The query used to build `OUTPUT` must include the grouping expression NAME in its projection."
      }
    },
    {
      "name": "multiple expressions - single key missing from projection",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The query used to build `OUTPUT` must include the grouping expression F1 in its projection."
      }
    },
    {
      "name": "multiple expression - key in projection more than once",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, f1 AS F3, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The projection contains a key column more than once: `F1` and `F3`."
      }
    },
    {
      "name": "multiple expressions - all keys missing from projection",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT, f3 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY f1, f2, f3;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The query used to build `OUTPUT` must include the grouping expressions F1, F2 and F3 in its projection."
      }
    },
    {
      "name": "select * where all columns in group by",
      "statements": [
        "CREATE STREAM TEST (id INT KEY, id2 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT *, COUNT() FROM TEST GROUP BY id, id2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"ID2": 2}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "1|+|2", "value": {"KSQL_COL_0": 1}}
      ]
    },
    {
      "name": "select * where not all columns in group by",
      "statements": [
        "CREATE STREAM TEST (id INT KEY, id2 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT *, COUNT() FROM TEST GROUP BY id;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: ID2"
      }
    },
    {
      "name": "with key alias that clashes with value alias",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA AS COUNT, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Duplicate value columns found in schema: `COUNT` BIGINT"
      }
    },
    {
      "name": "map used in non-aggregate function in select when group by uses subscript",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, VARCHAR>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo'], AS_VALUE(col1) AS foo, COUNT(*) FROM input GROUP BY col1['foo'];"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: AS_VALUE(COL1)\nEither add the column(s) to the GROUP BY or remove them from the SELECT."
      }
    },
    {
      "name": "complex UDAF params",
      "statements": [
        "CREATE STREAM TEST (V0 INT KEY, V1 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT V0, V1, SUM(V0 + V1) AS SUM FROM TEST GROUP BY V0, V1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}},
        {"topic": "test_topic", "key": 1, "value": {"V1": 20}},
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "0|+|10", "value": {"V0": 0, "V1": 10, "KSQL_INTERNAL_COL_2": 10}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "1|+|20", "value": {"V0": 1, "V1": 20, "KSQL_INTERNAL_COL_2": 21}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "0|+|10", "value": {"V0": 0, "V1": 10, "KSQL_INTERNAL_COL_2": 10}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "0|+|10", "value": {"V0": 0, "V1": 10, "KSQL_AGG_VARIABLE_0": 10}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "1|+|20", "value": {"V0": 1, "V1": 20, "KSQL_AGG_VARIABLE_0": 21}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "0|+|10", "value": {"V0": 0, "V1": 10, "KSQL_AGG_VARIABLE_0": 20}},
        {"topic": "OUTPUT", "key": "0|+|10", "value": {"SUM": 10}},
        {"topic": "OUTPUT", "key": "1|+|20", "value": {"SUM": 21}},
        {"topic": "OUTPUT", "key": "0|+|10", "value": {"SUM": 20}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, SUM INT"}
        ]
      }
    },
    {
      "name": "complex UDAF params matching GROUP BY",
      "statements": [
        "CREATE STREAM TEST (V0 INT KEY, V1 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT (V0 + V1) AS NEW_KEY, SUM(V0 + V1) AS SUM FROM TEST GROUP BY V0 + V1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}},
        {"topic": "test_topic", "key": 1, "value": {"V1": 20}},
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 10, "value": {"V0": 0, "V1": 10, "KSQL_INTERNAL_COL_2": 10}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 21, "value": {"V0": 1, "V1": 20, "KSQL_INTERNAL_COL_2": 21}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 10, "value": {"V0": 0, "V1": 10, "KSQL_INTERNAL_COL_2": 10}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 10, "value": {"V0": 0, "V1": 10, "KSQL_AGG_VARIABLE_0": 10}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 21, "value": {"V0": 1, "V1": 20, "KSQL_AGG_VARIABLE_0": 21}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 10, "value": {"V0": 0, "V1": 10, "KSQL_AGG_VARIABLE_0": 20}},
        {"topic": "OUTPUT", "key": 10, "value": {"SUM": 10}},
        {"topic": "OUTPUT", "key": 21, "value": {"SUM": 21}},
        {"topic": "OUTPUT", "key": 10, "value": {"SUM": 20}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY INT KEY, SUM INT"}
        ]
      }
    },
    {
      "name": "complex UDAF params matching HAVING",
      "statements": [
        "CREATE STREAM TEST (V0 INT KEY, V1 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT SUM(V0 + V1) AS SUM, V0, V1 FROM TEST GROUP BY V0, V1 HAVING V0 + V1 <= 20;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}},
        {"topic": "test_topic", "key": 1, "value": {"V1": 20}},
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "0|+|10", "value": {"V0": 0, "V1": 10, "KSQL_INTERNAL_COL_2": 10}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "1|+|20", "value": {"V0": 1, "V1": 20, "KSQL_INTERNAL_COL_2": 21}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "0|+|10", "value": {"V0": 0, "V1": 10, "KSQL_INTERNAL_COL_2": 10}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "0|+|10", "value": {"V0": 0, "V1": 10, "KSQL_AGG_VARIABLE_0": 10}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "1|+|20", "value": {"V0": 1, "V1": 20, "KSQL_AGG_VARIABLE_0": 21}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "0|+|10", "value": {"V0": 0, "V1": 10, "KSQL_AGG_VARIABLE_0": 20}},
        {"topic": "OUTPUT", "key": "0|+|10", "value": {"SUM": 10}},
        {"topic": "OUTPUT", "key": "1|+|20", "value": null},
        {"topic": "OUTPUT", "key": "0|+|10", "value": {"SUM": 20}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, SUM INT"}
        ]
      }
    },
    {
      "name": "single expression with nulls",
      "comment": "bad_udf return every other invocation - tables need a PRIMARY key so null keys are dropped",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT bad_udf(DATA), COUNT(*) FROM TEST GROUP BY bad_udf(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_1": 2}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "complex expressions",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY DATA AND ID;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.parser.exception.ParseFailedException",
        "message": "mismatched input 'AND' expecting ';'"
      }
    },
    {
      "name": "multiple expressions with nulls",
      "comment": "bad_udf returns null every other invocation - tables need a PRIMARY key so null keys are dropped",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT bad_udf(DATA), COUNT(*) FROM TEST GROUP BY bad_udf(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_1": 2}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT K, COUNT(*) FROM TEST GROUP BY K;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "d1", "value": "-"},
        {"topic": "test_topic", "key": "d2", "value": "-"},
        {"topic": "test_topic", "key": "d1", "value": "-"},
        {"topic": "test_topic", "key": "d2", "value": "-"},
        {"topic": "test_topic", "key": "d1", "value": "-"}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": "d1,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": "d2,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": "d1,0,2"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": "d2,0,2"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": "d1,0,3"},
        {"topic": "OUTPUT", "key": "d1", "value": "1"},
        {"topic": "OUTPUT", "key": "d2", "value": "1"},
        {"topic": "OUTPUT", "key": "d1", "value": "2"},
        {"topic": "OUTPUT", "key": "d2", "value": "2"},
        {"topic": "OUTPUT", "key": "d1", "value": "3"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "K STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "field (stream->table) - KAFKA",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='KAFKA');",
        "CREATE TABLE OUTPUT WITH(value_format='DELIMITED') AS SELECT DATA, COUNT(*) FROM TEST GROUP BY DATA;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Source(s) TEST are using the 'KAFKA' value format. This format does not yet support GROUP BY."
      }
    },
    {
      "name": "field (stream->table) - format",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='{FORMAT}');",
        "CREATE TABLE OUTPUT AS SELECT K, COUNT(*) FROM TEST GROUP BY K;"
      ],
      "format": ["AVRO", "JSON", "PROTOBUF"],
      "inputs": [
        {"topic": "test_topic", "key": "d1", "value": {}, "timestamp": 1},
        {"topic": "test_topic", "key": "d2", "value": {}, "timestamp": 2},
        {"topic": "test_topic", "key": "d1", "value": {}, "timestamp": 3},
        {"topic": "test_topic", "key": "d2", "value": {}, "timestamp": 4},
        {"topic": "test_topic", "key": "d1", "value": {}, "timestamp": 5}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"K": "d1", "ROWTIME": 1, "KSQL_AGG_VARIABLE_0": 1}, "timestamp": 1},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"K": "d2", "ROWTIME": 2, "KSQL_AGG_VARIABLE_0": 1}, "timestamp": 2},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"K": "d1", "ROWTIME": 3, "KSQL_AGG_VARIABLE_0": 2}, "timestamp": 3},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"K": "d2", "ROWTIME": 4, "KSQL_AGG_VARIABLE_0": 2}, "timestamp": 4},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"K": "d1", "ROWTIME": 5, "KSQL_AGG_VARIABLE_0": 3}, "timestamp": 5},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":1}, "timestamp": 1},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0":1}, "timestamp": 2},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":2}, "timestamp": 3},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0":2}, "timestamp": 4},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":3}, "timestamp": 5}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "K STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "int field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ID, COUNT(*) FROM TEST GROUP BY ID;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "a", "value": {"ID": 1}, "timestamp": 1},
        {"topic": "test_topic", "key": "b", "value": {"ID": 2}, "timestamp": 2},
        {"topic": "test_topic", "key": "c", "value": {"ID": 1}, "timestamp": 3},
        {"topic": "test_topic", "key": "d", "value": {"ID": 2}, "timestamp": 4},
        {"topic": "test_topic", "key": "e", "value": {"ID": 1}, "timestamp": 5}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 1, "value": {"ID": 1, "ROWTIME": 1, "KSQL_AGG_VARIABLE_0": 1}, "timestamp": 1},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ID": 2, "ROWTIME": 2, "KSQL_AGG_VARIABLE_0": 1}, "timestamp": 2},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 1, "value": {"ID": 1, "ROWTIME": 3, "KSQL_AGG_VARIABLE_0": 2}, "timestamp": 3},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": {"ID": 2, "ROWTIME": 4, "KSQL_AGG_VARIABLE_0": 2}, "timestamp": 4},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 1, "value": {"ID": 1, "ROWTIME": 5, "KSQL_AGG_VARIABLE_0": 3}, "timestamp": 5},
        {"topic": "OUTPUT", "key": 1, "value": {"KSQL_COL_0":1}, "timestamp": 1},
        {"topic": "OUTPUT", "key": 2, "value": {"KSQL_COL_0":1}, "timestamp": 2},
        {"topic": "OUTPUT", "key": 1, "value": {"KSQL_COL_0":2}, "timestamp": 3},
        {"topic": "OUTPUT", "key": 2, "value": {"KSQL_COL_0":2}, "timestamp": 4},
        {"topic": "OUTPUT", "key": 1, "value": {"KSQL_COL_0":3}, "timestamp": 5}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "ID INT KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,a"},
        {"topic": "test_topic", "key": 2, "value": "2,b"},
        {"topic": "test_topic", "key": 1, "value": "1,a"},
        {"topic": "test_topic", "key": 2, "value": "2,b"},
        {"topic": "test_topic", "key": 3, "value": "3,a"}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": "1,a,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": "2,b,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": "1,a,0,2"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": "2,b,0,2"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|3", "value": "3,a,0,1"},
        {"topic": "OUTPUT", "key": "a|+|1", "value": "1"},
        {"topic": "OUTPUT", "key": "b|+|2", "value": "1"},
        {"topic": "OUTPUT", "key": "a|+|1", "value": "2"},
        {"topic": "OUTPUT", "key": "b|+|2", "value": "2"},
        {"topic": "OUTPUT", "key": "a|+|3", "value": "1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_1 STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields used in expression",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT F1, F2, f1 / f2, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "4,2"},
        {"topic": "test_topic", "value": "9,3"},
        {"topic": "test_topic", "value": "9,3"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "4|+|2", "value": "2,1"},
        {"topic": "OUTPUT", "key": "9|+|3", "value": "3,1"},
        {"topic": "OUTPUT", "key": "9|+|3", "value": "3,2"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_2 STRING KEY, KSQL_COL_0 INTEGER, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "fields (stream->table) - format",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='{FORMAT}');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "format": ["AVRO", "JSON", "PROTOBUF"],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "a"}},
        {"topic": "test_topic", "key": 2, "value": {"F1": 2, "F2": "b"}},
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "a"}},
        {"topic": "test_topic", "key": 2, "value": {"F1": 2, "F2": "b"}},
        {"topic": "test_topic", "key": 3, "value": {"F1": 3, "F2": "a"}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": {"F1": 1, "F2": "a", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": {"F1": 2, "F2": "b", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": {"F1": 1, "F2": "a", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": {"F1": 2, "F2": "b", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|3", "value": {"F1": 3, "F2": "a", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "OUTPUT", "key": "a|+|1", "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "b|+|2", "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "a|+|1", "value": {"KSQL_COL_0": 2}},
        {"topic": "OUTPUT", "key": "b|+|2", "value": {"KSQL_COL_0": 2}},
        {"topic": "OUTPUT", "key": "a|+|3", "value": {"KSQL_COL_0": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_1 STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "with groupings (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT, f2 VARCHAR, f3 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f3, (f2, f1);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.parser.exception.ParseFailedException",
        "message": "line 2:74: missing ')' at ','"
      }
    },
    {
      "name": "duplicate expressions",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY DATA, TEST.DATA;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Duplicate GROUP BY expression: TEST.DATA"
      }
    },
    {
      "name": "with single grouping set (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT, f2 VARCHAR, f3 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, f3, COUNT(*) FROM TEST GROUP BY (f3, f2, f1);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,a,-1"},
        {"topic": "test_topic", "key": 2, "value": "2,b,-2"},
        {"topic": "test_topic", "key": 1, "value": "1,a,-1"},
        {"topic": "test_topic", "key": 2, "value": "2,b,-2"},
        {"topic": "test_topic", "key": 3, "value": "3,a,-3"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "-1|+|a|+|1", "value": "1"},
        {"topic": "OUTPUT", "key": "-2|+|b|+|2", "value": "1"},
        {"topic": "OUTPUT", "key": "-1|+|a|+|1", "value": "2"},
        {"topic": "OUTPUT", "key": "-2|+|b|+|2", "value": "2"},
        {"topic": "OUTPUT", "key": "-3|+|a|+|3", "value": "1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_1 STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,a"},
        {"topic": "test_topic", "key": 2, "value": "2,b"},
        {"topic": "test_topic", "key": 1, "value": "1,b"},
        {"topic": "test_topic", "key": 2, "value": null},
        {"topic": "test_topic", "key": 1, "value": "1,a"}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": "1,a,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": "2,b,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": "1,a,0,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|1", "value": "1,b,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": "2,b,0,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|1", "value": "1,b,0,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": "1,a,0,1"},
        {"topic": "OUTPUT", "key": "a|+|1", "value": "1"},
        {"topic": "OUTPUT", "key": "b|+|2", "value": "1"},
        {"topic": "OUTPUT", "key": "a|+|1", "value": "0"},
        {"topic": "OUTPUT", "key": "b|+|1", "value": "1"},
        {"topic": "OUTPUT", "key": "b|+|2", "value": "0"},
        {"topic": "OUTPUT", "key": "b|+|1", "value": "0"},
        {"topic": "OUTPUT", "key": "a|+|1", "value": "1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_1 STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields - copied into value (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, AS_VALUE(f1) AS F3, AS_VALUE(F2) AS F4, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,a"},
        {"topic": "test_topic", "key": 2, "value": "2,b"},
        {"topic": "test_topic", "key": 1, "value": "1,b"},
        {"topic": "test_topic", "key": 2, "value": null},
        {"topic": "test_topic", "key": 1, "value": "1,a"}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": "1,a,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": "2,b,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": "1,a,0,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|1", "value": "1,b,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": "2,b,0,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|1", "value": "1,b,0,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": "1,a,0,1"},
        {"topic": "OUTPUT", "key": "a|+|1", "value": "1,a,1"},
        {"topic": "OUTPUT", "key": "b|+|2", "value": "2,b,1"},
        {"topic": "OUTPUT", "key": "a|+|1", "value": "1,a,0"},
        {"topic": "OUTPUT", "key": "b|+|1", "value": "1,b,1"},
        {"topic": "OUTPUT", "key": "b|+|2", "value": "2,b,0"},
        {"topic": "OUTPUT", "key": "b|+|1", "value": "1,b,0"},
        {"topic": "OUTPUT", "key": "a|+|1", "value": "1,a,1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_1 STRING KEY, F3 INT, F4 STRING, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields (table->table) - format",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='{FORMAT}');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "format": ["AVRO", "JSON", "PROTOBUF"],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "a"}},
        {"topic": "test_topic", "key": 2, "value": {"F1": 2, "F2": "b"}},
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "b"}},
        {"topic": "test_topic", "key": 2, "value": null},
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "a"}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": {"F1": 1, "F2": "a", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": {"F1": 2, "F2": "b", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": {"F1": 1, "F2": "a", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 0}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|1", "value": {"F1": 1, "F2": "b", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|2", "value": {"F1": 2, "F2": "b", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 0}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "b|+|1", "value": {"F1": 1, "F2": "b", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 0}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "a|+|1", "value": {"F1": 1, "F2": "a", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "OUTPUT", "key": "a|+|1", "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "b|+|2", "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "a|+|1", "value": {"KSQL_COL_0": 0}},
        {"topic": "OUTPUT", "key": "b|+|1", "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": "b|+|2", "value": {"KSQL_COL_0": 0}},
        {"topic": "OUTPUT", "key": "b|+|1", "value": {"KSQL_COL_0": 0}},
        {"topic": "OUTPUT", "key": "a|+|1", "value": {"KSQL_COL_0": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_1 STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "field with re-key (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "d1"},
        {"topic": "test_topic", "value": "d2"},
        {"topic": "test_topic", "value": "d1"},
        {"topic": "test_topic", "value": "d2"},
        {"topic": "test_topic", "value": "d1"}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": "d1,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": "d2,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": "d1,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": "d2,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": "d1,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": "d1,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": "d2,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": "d1,0,2"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": "d2,0,2"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": "d1,0,3"},
        {"topic": "OUTPUT", "key": "d1", "value": "1"},
        {"topic": "OUTPUT", "key": "d2", "value": "1"},
        {"topic": "OUTPUT", "key": "d1", "value": "2"},
        {"topic": "OUTPUT", "key": "d2", "value": "2"},
        {"topic": "OUTPUT", "key": "d1", "value": "3"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "double field with re-key (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data double) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "0.1"},
        {"topic": "test_topic", "value": "0.2"},
        {"topic": "test_topic", "value": "0.1"},
        {"topic": "test_topic", "value": "0.2"},
        {"topic": "test_topic", "value": "0.1"}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 0.1, "value": "0.1,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 0.2, "value": "0.2,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 0.1, "value": "0.1,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 0.2, "value": "0.2,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 0.1, "value": "0.1,0"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 0.1, "value": "0.1,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 0.2, "value": "0.2,0,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 0.1, "value": "0.1,0,2"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 0.2, "value": "0.2,0,2"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 0.1, "value": "0.1,0,3"},
        {"topic": "OUTPUT", "key": 0.1, "value": "1"},
        {"topic": "OUTPUT", "key": 0.2, "value": "1"},
        {"topic": "OUTPUT", "key": 0.1, "value": "2"},
        {"topic": "OUTPUT", "key": 0.2, "value": "2"},
        {"topic": "OUTPUT", "key": 0.1, "value": "3"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA DOUBLE KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "field with re-key (stream->table) - format",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='{FORMAT}');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) FROM TEST GROUP BY DATA;"
      ],
      "format": ["AVRO", "JSON", "PROTOBUF"],
      "inputs": [
        {"topic": "test_topic", "value": {"DATA": "d1"}},
        {"topic": "test_topic", "value": {"DATA": "d2"}},
        {"topic": "test_topic", "value": {"DATA": "d1"}},
        {"topic": "test_topic", "value": {"DATA": "d2"}},
        {"topic": "test_topic", "value": {"DATA": "d1"}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"DATA": "d1", "ROWTIME": 0}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": {"DATA": "d2", "ROWTIME": 0}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"DATA": "d1", "ROWTIME": 0}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d2", "value": {"DATA": "d2", "ROWTIME": 0}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": "d1", "value": {"DATA": "d1", "ROWTIME": 0}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"DATA": "d1", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"DATA": "d2", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"DATA": "d1", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"DATA": "d2", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"DATA": "d1", "ROWTIME": 0, "KSQL_AGG_VARIABLE_0": 3}},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0":1}},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":2}},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0":2}},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "field with re-key (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT region, COUNT(*) FROM TEST GROUP BY region;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,r0"},
        {"topic": "test_topic", "key": 2, "value": "2,r1"},
        {"topic": "test_topic", "key": 3, "value": "3,r0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,r0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0", "value": "1"},
        {"topic": "OUTPUT", "key": "r1", "value": "1"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"},
        {"topic": "OUTPUT", "key": "r0", "value": "1"},
        {"topic": "OUTPUT", "key": "r1", "value": "0"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "REGION STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "with aggregate arithmetic (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*)*2 FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "d1"},
        {"topic": "test_topic", "value": "d2"},
        {"topic": "test_topic", "value": "d1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": "2"},
        {"topic": "OUTPUT", "key": "d2", "value": "2"},
        {"topic": "OUTPUT", "key": "d1", "value": "4"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "with aggregate arithmetic (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT region, COUNT(*) * 2 FROM TEST GROUP BY region;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,r0"},
        {"topic": "test_topic", "key": 2, "value": "2,r1"},
        {"topic": "test_topic", "key": 3, "value": "3,r0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,r0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0", "value": "2"},
        {"topic": "OUTPUT", "key": "r1", "value": "2"},
        {"topic": "OUTPUT", "key": "r0", "value": "4"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"},
        {"topic": "OUTPUT", "key": "r1", "value": "0"},
        {"topic": "OUTPUT", "key": "r0", "value": "4"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "REGION STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "with aggregate arithmetic involving source field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ITEM INT, COST INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT ITEM, COST, COST * COUNT() FROM TEST GROUP BY ITEM, COST;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "1,10"},
        {"topic": "test_topic", "value": "1,20"},
        {"topic": "test_topic", "value": "2,30"},
        {"topic": "test_topic", "value": "1,10"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "1|+|10", "value": "10"},
        {"topic": "OUTPUT", "key": "1|+|20", "value": "20"},
        {"topic": "OUTPUT", "key": "2|+|30", "value": "30"},
        {"topic": "OUTPUT", "key": "1|+|10", "value": "20"}
      ]
    },
    {
      "name": "with aggregate arithmetic involving source field (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f0 INT, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f0, f0 * SUM(f1) FROM TEST GROUP BY f0;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 2, "value": "2,10"},
        {"topic": "test_topic", "key": 2, "value": "2,20"},
        {"topic": "test_topic", "key": 2, "value": "2,30"},
        {"topic": "test_topic", "key": 2, "value": null}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": "20"},
        {"topic": "OUTPUT", "key": 2, "value": "0"},
        {"topic": "OUTPUT", "key": 2, "value": "40"},
        {"topic": "OUTPUT", "key": 2, "value": "0"},
        {"topic": "OUTPUT", "key": 2, "value": "60"},
        {"topic": "OUTPUT", "key": 2, "value": "0"}
      ]
    },
    {
      "name": "with aggregate arithmetic involving source field not in group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f0 INT, f1 INT, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1 * SUM(f2) FROM TEST GROUP BY f0;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (F1 * SUM(F2))\nEither add the column(s) to the GROUP BY or remove them from the SELECT."
      }
    },
    {
      "name": "function (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, source VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(source, 0, 2), COUNT(*) FROM TEST GROUP BY SUBSTRING(source, 0, 2);"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "some string"},
        {"topic": "test_topic", "value": "another string"},
        {"topic": "test_topic", "value": "some string again"},
        {"topic": "test_topic", "value": "another string again"},
        {"topic": "test_topic", "value": "some other string"},
        {"topic": "test_topic", "value": "the final string"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "so", "value": "1"},
        {"topic": "OUTPUT", "key": "an", "value": "1"},
        {"topic": "OUTPUT", "key": "so", "value": "2"},
        {"topic": "OUTPUT", "key": "an", "value": "2"},
        {"topic": "OUTPUT", "key": "so", "value": "3"},
        {"topic": "OUTPUT", "key": "th", "value": "1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "function (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(region, 7, 2), COUNT(*) FROM TEST GROUP BY SUBSTRING(region, 7, 2);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,prefixr0"},
        {"topic": "test_topic", "key": 2, "value": "2,prefixr1"},
        {"topic": "test_topic", "key": 3, "value": "3,prefixr0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,prefixr0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0", "value": "1"},
        {"topic": "OUTPUT", "key": "r1", "value": "1"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"},
        {"topic": "OUTPUT", "key": "r0", "value": "1"},
        {"topic": "OUTPUT", "key": "r1", "value": "0"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "int function (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT LEN(region), COUNT(*) FROM TEST GROUP BY LEN(region);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "usa"},
        {"topic": "test_topic", "key": "2", "value": "eu"},
        {"topic": "test_topic", "key": "3", "value": "usa"},
        {"topic": "test_topic", "key": "1", "value": null},
        {"topic": "test_topic", "key": "2", "value": "usa"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 3, "value": "1"},
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 3, "value": "2"},
        {"topic": "OUTPUT", "key": 3, "value": "1"},
        {"topic": "OUTPUT", "key": 2, "value": "0"},
        {"topic": "OUTPUT", "key": 3, "value": "2"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 INT KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "function with select field that is a subset of group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, source VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(source, 0, 1) AS Thing, COUNT(*) FROM TEST GROUP BY SUBSTRING(source, 0, 2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBSTRING(SOURCE, 0, 1)"
      }
    },
    {
      "name": "function with select field that is a subset of group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(region, 7, 1), COUNT(*) FROM TEST GROUP BY SUBSTRING(region, 7, 2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBSTRING(REGION, 7, 1)"
      }
    },
    {
      "name": "function with select field that is a superset of group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, source VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(source, 0, 3), COUNT(*) FROM TEST GROUP BY SUBSTRING(source, 0, 2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBSTRING(SOURCE, 0, 3)"
      }
    },
    {
      "name": "function with select field that is a superset of group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (K INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(region, 7, 3), COUNT(*) FROM TEST GROUP BY SUBSTRING(region, 7, 2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBSTRING(REGION, 7, 3)"
      }
    },
    {
      "name": "function with having field that is a subset of group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, source VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(source, 0, 2) AS Thing, COUNT(*) FROM TEST GROUP BY SUBSTRING(source, 0, 2) HAVING LEN(source) < 2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate HAVING expression not part of GROUP BY: SOURCE"
      }
    },
    {
      "name": "json field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (data STRUCT<field VARCHAR>) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT data->field AS FIELD, COUNT(*) AS COUNT FROM TEST GROUP BY data->field;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"data": {"field": "Something"}}},
        {"topic": "test_topic", "value": {"data": {"field": "Something Else"}}},
        {"topic": "test_topic", "value": {"data": {}}},
        {"topic": "test_topic", "value": {"data": {"field": "Something"}}},
        {"topic": "test_topic", "value": {"data": {}}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "Something", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "Something Else", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "Something", "value": {"COUNT": 2}}
      ]
    },
    {
      "name": "int json field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (data STRUCT<field INT>) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT data->field, COUNT(*) AS COUNT FROM TEST GROUP BY data->field;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"data": {"field": 1}}},
        {"topic": "test_topic", "value": {"data": {"field": 2}}},
        {"topic": "test_topic", "value": {"data": {}}},
        {"topic": "test_topic", "value": {"data": {"field": 1}}},
        {"topic": "test_topic", "value": {"data": {}}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 1, "value": {"COUNT": 2}}
      ]
    },
    {
      "name": "key (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT K, COUNT(*) FROM TEST GROUP BY K;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "-"},
        {"topic": "test_topic", "key": "2", "value": "-"},
        {"topic": "test_topic", "key": "1", "value": "-"},
        {"topic": "test_topic", "key": "2", "value": "-"},
        {"topic": "test_topic", "key": "1", "value": "-"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "1", "value": "1"},
        {"topic": "OUTPUT", "key": "2", "value": "1"},
        {"topic": "OUTPUT", "key": "1", "value": "2"},
        {"topic": "OUTPUT", "key": "2", "value": "2"},
        {"topic": "OUTPUT", "key": "1", "value": "3"}
      ],
      "post": {
        "topics": {
          "blacklist": ".*-repartition"
        }
      }
    },
    {
      "name": "ROWTIME (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT ROWTIME AS RT, COUNT(*) FROM TEST GROUP BY ROWTIME;"
      ],
      "inputs": [{"topic": "test_topic", "value": "-", "timestamp":  10}],
      "outputs": [{"topic": "OUTPUT", "key": 10, "value": "1", "timestamp":  10}]
    },
    {
      "name": "constant (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT 1, COUNT(*) FROM TEST GROUP BY 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "-"},
        {"topic": "test_topic", "value": "-"},
        {"topic": "test_topic", "value": "-"},
        {"topic": "test_topic", "value": "-"},
        {"topic": "test_topic", "value": "-"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 1, "value": "3"},
        {"topic": "OUTPUT", "key": 1, "value": "4"},
        {"topic": "OUTPUT", "key": 1, "value": "5"}
      ]
    },
    {
      "name": "constant (table->table)",
      "statements": [
        "CREATE TABLE TEST (K INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT 1, COUNT(*) FROM TEST GROUP BY 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,r0"},
        {"topic": "test_topic", "key": 2, "value": "2,r1"},
        {"topic": "test_topic", "key": 3, "value": "3,r0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,r0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 1, "value": "3"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"}
      ]
    },
    {
      "name": "field with field used in function in projection (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, SUBSTRING(f1, 0, 1), COUNT(*) FROM TEST GROUP BY f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "one"},
        {"topic": "test_topic", "value": "two"},
        {"topic": "test_topic", "value": "three"},
        {"topic": "test_topic", "value": "one"},
        {"topic": "test_topic", "value": "five"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "one", "value": "o,1"},
        {"topic": "OUTPUT", "key": "two", "value": "t,1"},
        {"topic": "OUTPUT", "key": "three", "value": "t,1"},
        {"topic": "OUTPUT", "key": "one", "value": "o,2"},
        {"topic": "OUTPUT", "key": "five", "value": "f,1"}
      ]
    },
    {
      "name": "field with field used in function in projection (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT region, SUBSTRING(region, 2, 1), COUNT(*) FROM TEST GROUP BY region;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,r0"},
        {"topic": "test_topic", "key": 2, "value": "2,r1"},
        {"topic": "test_topic", "key": 3, "value": "3,r0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,r0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0", "value": "0,1"},
        {"topic": "OUTPUT", "key": "r1", "value": "1,1"},
        {"topic": "OUTPUT", "key": "r0", "value": "0,2"},
        {"topic": "OUTPUT", "key": "r0", "value": "0,1"},
        {"topic": "OUTPUT", "key": "r1", "value": "1,0"},
        {"topic": "OUTPUT", "key": "r0", "value": "0,2"}
      ]
    },
    {
      "name": "string concat using + op (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 VARCHAR, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2 + f1, COUNT(*) FROM TEST GROUP BY f2 + f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "1,a"},
        {"topic": "test_topic", "value": "2,b"},
        {"topic": "test_topic", "value": "1,a"},
        {"topic": "test_topic", "value": "2,b"},
        {"topic": "test_topic", "value": "3,a"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a1", "value": "1"},
        {"topic": "OUTPUT", "key": "b2", "value": "1"},
        {"topic": "OUTPUT", "key": "a1", "value": "2"},
        {"topic": "OUTPUT", "key": "b2", "value": "2"},
        {"topic": "OUTPUT", "key": "a3", "value": "1"}
      ]
    },
    {
      "name": "string concat using + op (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, user INT, subregion VARCHAR, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT region + subregion, COUNT(*) FROM TEST GROUP BY region + subregion;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,a,r0"},
        {"topic": "test_topic", "key": "2", "value": "2,a,r1"},
        {"topic": "test_topic", "key": "3", "value": "3,a,r0"},
        {"topic": "test_topic", "key": "4", "value": "4,b,r0"},
        {"topic": "test_topic", "key": "1", "value": null},
        {"topic": "test_topic", "key": "2", "value": "2,a,r0"},
        {"topic": "test_topic", "key": "2", "value": "2,b,r1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0a", "value": "1"},
        {"topic": "OUTPUT", "key": "r1a", "value": "1"},
        {"topic": "OUTPUT", "key": "r0a", "value": "2"},
        {"topic": "OUTPUT", "key": "r0b", "value": "1"},
        {"topic": "OUTPUT", "key": "r0a", "value": "1"},
        {"topic": "OUTPUT", "key": "r1a", "value": "0"},
        {"topic": "OUTPUT", "key": "r0a", "value": "2"},
        {"topic": "OUTPUT", "key": "r0a", "value": "1"},
        {"topic": "OUTPUT", "key": "r1b", "value": "1"}
      ]
    },
    {
      "name": "string concat using + op with projection field in wrong order (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 VARCHAR, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1 + f2, COUNT(*) FROM TEST GROUP BY f2 + f1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (F1 + F2)"
      }
    },
    {
      "name": "string concat using + op with projection field in wrong order (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, user INT, subregion VARCHAR, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT subregion + region, COUNT(*) FROM TEST GROUP BY region + subregion;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (SUBREGION + REGION)"
      }
    },
    {
      "name": "string concat with separate fields in projection (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 VARCHAR, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2 + f1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: F1, F2"
      }
    },
    {
      "name": "string concat with separate fields in projection (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, user INT, subregion VARCHAR, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT subregion, region, COUNT(*) FROM TEST GROUP BY region + subregion;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBREGION, REGION"
      }
    },
    {
      "name": "arithmetic binary expression with projection in-order & non-commutative group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2 - f1, COUNT(*) FROM TEST GROUP BY f2 - f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "1,2"},
        {"topic": "test_topic", "value": "2,3"},
        {"topic": "test_topic", "value": "2,4"},
        {"topic": "test_topic", "value": "6,8"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 2, "value": "2"}
      ]
    },
    {
      "name": "arithmetic binary expression with projection in-order & non-commutative group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, f0 INT, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f0 - f1, COUNT(*) FROM TEST GROUP BY f0 - f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,0"},
        {"topic": "test_topic", "key": "2", "value": "2,1"},
        {"topic": "test_topic", "key": "3", "value": "3,1"},
        {"topic": "test_topic", "key": "1", "value": null},
        {"topic": "test_topic", "key": "2", "value": "4,2"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "0"},
        {"topic": "OUTPUT", "key": 2, "value": "2"}
      ]
    },
    {
      "name": "arithmetic binary expression with projection out-of-order & non-commutative group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1 - f2, COUNT(*) FROM TEST GROUP BY f2 - f1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (F1 - F2)"
      }
    },
    {
      "name": "arithmetic binary expression with projection out-of-order & non-commutative group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, f0 INT, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1 - f0, COUNT(*) FROM TEST GROUP BY f0 - f1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (F1 - F0)"
      }
    },
    {
      "name": "with having expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, COUNT(*) FROM TEST GROUP BY f1 HAVING SUM(f1) > 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1"},
        {"topic": "test_topic", "key": 2, "value": "2"},
        {"topic": "test_topic", "key": 1, "value": "1"},
        {"topic": "test_topic", "key": 2, "value": "2"},
        {"topic": "test_topic", "key": 3, "value": "3"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": null},
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 2, "value": "2"},
        {"topic": "OUTPUT", "key": 3, "value": "1"}
      ]
    },
    {
      "name": "with having expression (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, f0 INT, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, SUM(f0) FROM TEST GROUP BY f1 HAVING COUNT(f1) > 0;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,0"},
        {"topic": "test_topic", "key": "2", "value": "2,1"},
        {"topic": "test_topic", "key": "3", "value": "3,0"},
        {"topic": "test_topic", "key": "1", "value": null},
        {"topic": "test_topic", "key": "2", "value": "2,0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 0, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 0, "value": "4"},
        {"topic": "OUTPUT", "key": 0, "value": "3"},
        {"topic": "OUTPUT", "key": 1, "value": null},
        {"topic": "OUTPUT", "key": 0, "value": "5"}
      ]
    },
    {
      "name": "with multiple having expressions (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, COUNT(f1) FROM TEST GROUP BY f1 HAVING COUNT(f1) > 1 AND f1=1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "0", "value": "1,a"},
        {"topic": "test_topic", "key": "0", "value": "2,b"},
        {"topic": "test_topic", "key": "0", "value": "1,test"},
        {"topic": "test_topic", "key": "0", "value": "2,test"},
        {"topic": "test_topic", "key": "0", "value": "2,test"},
        {"topic": "test_topic", "key": "0", "value": "1,test"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": null},
        {"topic": "OUTPUT", "key": 2, "value": null},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 2, "value": null},
        {"topic": "OUTPUT", "key": 2, "value": null},
        {"topic": "OUTPUT", "key": 1, "value": "3"}
      ]
    },
    {
      "name": "with having expression on non-group-by field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2, COUNT(*) FROM TEST GROUP BY f2 HAVING SUM(f1) > 10;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "-", "value": "5,a"},
        {"topic": "test_topic", "key": "-", "value": "10,b"},
        {"topic": "test_topic", "key": "-", "value": "6,a"},
        {"topic": "test_topic", "key": "-", "value": "1,b"},
        {"topic": "test_topic", "key": "-", "value": "-1,a"},
        {"topic": "test_topic", "key": "-", "value": "1,a"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a", "value": null},
        {"topic": "OUTPUT", "key": "b", "value": null},
        {"topic": "OUTPUT", "key": "a", "value": "2"},
        {"topic": "OUTPUT", "key": "b", "value": "2"},
        {"topic": "OUTPUT", "key": "a", "value": null},
        {"topic": "OUTPUT", "key": "a", "value": "4"}
      ]
    },
    {
      "name": "with constant having (stream-table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2, SUM(f1) FROM TEST GROUP BY f2 HAVING f2='test';"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "0", "value": "1,a"},
        {"topic": "test_topic", "key": "0", "value": "2,b"},
        {"topic": "test_topic", "key": "0", "value": "2,test"},
        {"topic": "test_topic", "key": "0", "value": "2,b"},
        {"topic": "test_topic", "key": "0", "value": "3,test"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a", "value": null},
        {"topic": "OUTPUT", "key": "b", "value": null},
        {"topic": "OUTPUT", "key": "test", "value": "2"},
        {"topic": "OUTPUT", "key": "b", "value": null},
        {"topic": "OUTPUT", "key": "test", "value": "5"}
      ]
    },
    {
      "name": "with constants in the projection (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, 'some constant' as f3, COUNT(f1) FROM TEST GROUP BY f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1"},
        {"topic": "test_topic", "key": 2, "value": "2"},
        {"topic": "test_topic", "key": 1, "value": "1"},
        {"topic": "test_topic", "key": 2, "value": "2"},
        {"topic": "test_topic", "key": 3, "value": "3"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "some constant,1"},
        {"topic": "OUTPUT", "key": 2, "value": "some constant,1"},
        {"topic": "OUTPUT", "key": 1, "value": "some constant,2"},
        {"topic": "OUTPUT", "key": 2, "value": "some constant,2"},
        {"topic": "OUTPUT", "key": 3, "value": "some constant,1"}
      ]
    },
    {
      "name": "missing matching projection field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT data, COUNT(*) FROM TEST GROUP BY data;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 1},
        {"topic": "test_topic", "value": {"DATA": "d2"}, "timestamp": 2},
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 3}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 1, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 1}, "timestamp": 1},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"ROWTIME": 2, "DATA": "d2", "KSQL_AGG_VARIABLE_0": 1}, "timestamp": 2},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"ROWTIME": 3, "DATA": "d1", "KSQL_AGG_VARIABLE_0": 2}, "timestamp": 3},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 1}, "timestamp": 1},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0": 1}, "timestamp": 2},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 2}, "timestamp": 3}
      ]
    },
    {
      "name": "missing matching projection field (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT F2, COUNT(*) FROM TEST GROUP BY f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,a"},
        {"topic": "test_topic", "key": "2", "value": "2,b"},
        {"topic": "test_topic", "key": "1", "value": "1,b"},
        {"topic": "test_topic", "key": "2", "value": null},
        {"topic": "test_topic", "key": "1", "value": "1,a"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a", "value": "1"},
        {"topic": "OUTPUT", "key": "b", "value": "1"},
        {"topic": "OUTPUT", "key": "a", "value": "0"},
        {"topic": "OUTPUT", "key": "b", "value": "2"},
        {"topic": "OUTPUT", "key": "b", "value": "1"},
        {"topic": "OUTPUT", "key": "b", "value": "0"},
        {"topic": "OUTPUT", "key": "a", "value": "1"}
      ]
    },
    {
      "name": "duplicate fields (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(1), COUNT(*), AS_VALUE(DATA) AS COPY FROM TEST GROUP BY data;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 1},
        {"topic": "test_topic", "value": {"DATA": "d2"}, "timestamp": 2},
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 3}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"DATA": "d1", "ROWTIME": 1, "KSQL_AGG_VARIABLE_0": 1, "KSQL_AGG_VARIABLE_1": 1}, "timestamp": 1},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"DATA": "d2", "ROWTIME": 2, "KSQL_AGG_VARIABLE_0": 1, "KSQL_AGG_VARIABLE_1": 1}, "timestamp": 2},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"DATA": "d1", "ROWTIME": 3, "KSQL_AGG_VARIABLE_0": 2, "KSQL_AGG_VARIABLE_1": 2}, "timestamp": 3},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 1, "KSQL_COL_1": 1, "COPY": "d1"}, "timestamp": 1},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0": 1, "KSQL_COL_1": 1, "COPY": "d2"}, "timestamp": 2},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 2, "KSQL_COL_1": 2, "COPY": "d1"}, "timestamp": 3}
      ]
    },
    {
      "name": "duplicate udafs (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(1), COUNT(1) FROM TEST GROUP BY data;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 1},
        {"topic": "test_topic", "value": {"DATA": "d2"}, "timestamp": 2},
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 3}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"DATA": "d1", "KSQL_AGG_VARIABLE_0": 1, "KSQL_AGG_VARIABLE_1": 1}, "timestamp": 1},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d2", "value": {"DATA": "d2", "KSQL_AGG_VARIABLE_0": 1, "KSQL_AGG_VARIABLE_1": 1}, "timestamp": 2},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": "d1", "value": {"DATA": "d1", "KSQL_AGG_VARIABLE_0": 2, "KSQL_AGG_VARIABLE_1": 2}, "timestamp": 3},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 1, "KSQL_COL_1": 1}, "timestamp": 1},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0": 1, "KSQL_COL_1": 1}, "timestamp": 2},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 2, "KSQL_COL_1": 2}, "timestamp": 3}
      ]
    },
    {
      "name": "with non-aggregate projection field not in group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, COUNT(*) FROM TEST GROUP BY d2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: D1"
      }
    },
    {
      "name": "with non-aggregate projection field not in group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, d1 VARCHAR, d2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, COUNT(*) FROM TEST GROUP BY d2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: D1"
      }
    },
    {
      "name": "aggregate function (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY SUM(d2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "GROUP BY does not support aggregate functions: SUM is an aggregate function."
      }
    },
    {
      "name": "aggregate function nested in arithmetic (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY 1 + SUM(d2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "GROUP BY does not support aggregate functions: SUM is an aggregate function."
      }
    },
    {
      "name": "aggregate function nested in UDF (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY SUBSTRING(d1, SUM(d2), 1);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "GROUP BY does not support aggregate functions: SUM is an aggregate function."
      }
    },
    {
      "name": "without aggregate functions (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(d1, 1, 2) FROM TEST GROUP BY d2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "GROUP BY requires aggregate functions in either the SELECT or HAVING clause."
      }
    },
    {
      "name": "without group-by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, COUNT() FROM TEST;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Use of aggregate function COUNT requires a GROUP BY clause"
      }
    },
    {
      "name": "UDAF nested in UDF in select expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT D1, SUBSTRING('Mr Bugalicious', CAST(COUNT(*) AS INT), 1) FROM TEST GROUP BY d1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "x"},
        {"topic": "test_topic", "value": "xxx"},
        {"topic": "test_topic", "value": "y"},
        {"topic": "test_topic", "value": "x"},
        {"topic": "test_topic", "value": "xxx"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "x", "value": "M"},
        {"topic": "OUTPUT", "key": "xxx", "value": "M"},
        {"topic": "OUTPUT", "key": "y", "value": "M"},
        {"topic": "OUTPUT", "key": "x", "value": "r"},
        {"topic": "OUTPUT", "key": "xxx", "value": "r"}
      ]
    },
    {
      "name": "UDAF nested in UDF in select expression (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, d0 INT, d1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, SUBSTRING('Mr Bugalicious', CAST(COUNT(*) AS INT), 1) FROM TEST GROUP BY d1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "0", "value": "0,x"},
        {"topic": "test_topic", "key": "1", "value": "1,x"},
        {"topic": "test_topic", "key": "2", "value": "2,xxx"},
        {"topic": "test_topic", "key": "3", "value": "3,xxx"},
        {"topic": "test_topic", "key": "1", "value": null},
        {"topic": "test_topic", "key": "2", "value": "2,yy"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "x", "value": "M"},
        {"topic": "OUTPUT", "key": "x", "value": "r"},
        {"topic": "OUTPUT", "key": "xxx", "value": "M"},
        {"topic": "OUTPUT", "key": "xxx", "value": "r"},
        {"topic": "OUTPUT", "key": "x", "value": "M"},
        {"topic": "OUTPUT", "key": "xxx", "value": "M"},
        {"topic": "OUTPUT", "key": "yy", "value": "M"}
      ]
    },
    {
      "name": "UDF nested in UDAF in select expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, SUM(LEN(d1)) FROM TEST GROUP BY d1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "x"},
        {"topic": "test_topic", "value": "xxx"},
        {"topic": "test_topic", "value": "y"},
        {"topic": "test_topic", "value": "x"},
        {"topic": "test_topic", "value": "xxx"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "x", "value": "1"},
        {"topic": "OUTPUT", "key": "xxx", "value": "3"},
        {"topic": "OUTPUT", "key": "y", "value": "1"},
        {"topic": "OUTPUT", "key": "x", "value": "2"},
        {"topic": "OUTPUT", "key": "xxx", "value": "6"}
      ]
    },
    {
      "name": "UDAF nested in UDAF in select expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUM(COUNT()) FROM TEST GROUP BY d1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Aggregate functions can not be nested: SUM(COUNT())"
      }
    },
    {
      "name": "should exclude any stream row whose single GROUP BY expression resolves to NULL",
      "comment": "Passing NULL as the POS to SUBSTRING should resolve to NULL without an exception",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, str STRING, pos INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(str, pos), COUNT() FROM TEST GROUP BY SUBSTRING(str, pos);"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "xx,1"},
        {"topic": "test_topic", "value": "x,"},
        {"topic": "test_topic", "value": "xx,1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "xx", "value": "1"},
        {"topic": "OUTPUT", "key": "xx", "value": "2"}
      ]
    },
    {
      "name": "should exclude any table row whose single GROUP BY expression resolves to NULL",
      "comment": "Passing NULL as the POS to SUBSTRING should resolve to NULL without an exception",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, str STRING, pos INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(str, pos), COUNT() FROM TEST GROUP BY SUBSTRING(str, pos);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "xx,1"},
        {"topic": "test_topic", "key": "2", "value": "x,"},
        {"topic": "test_topic", "key": "3", "value": "xx,1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "xx", "value": "1"},
        {"topic": "OUTPUT", "key": "xx", "value": "2"}
      ]
    },
    {
      "name": "should exclude any stream row whose single GROUP BY expression throws",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, id INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT BAD_UDF(id), COUNT() FROM TEST GROUP BY BAD_UDF(id);"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "1"}
      ],
      "outputs": [
      ]
    },
    {
      "name": "should exclude any table row whose single GROUP BY expression throws",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, id INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT BAD_UDF(id), COUNT() FROM TEST GROUP BY BAD_UDF(id);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "2", "value": "1"}
      ],
      "outputs": [
      ]
    },
    {
      "name": "by non-STRING key",
      "statements": [
        "CREATE STREAM INPUT (K STRING KEY, f0 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f0, COUNT(1) FROM INPUT GROUP BY f0;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "2"},
        {"topic": "test_topic", "value": "3"},
        {"topic": "test_topic", "value": "2"}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": "2,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 3, "value": "3,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-GroupBy-repartition", "key": 2, "value": "2,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": "2,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 3, "value": "3,1"},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "key": 2, "value": "2,2"},
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 3, "value": "1"},
        {"topic": "OUTPUT", "key": 2, "value": "2"}
      ],
      "post": {
        "sources": [
          {
            "name": "OUTPUT",
            "type": "table",
            "keyFormat": {"format": "KAFKA"},
            "schema": "F0 INTEGER KEY, KSQL_COL_0 BIGINT"
          }
        ]
      }
    },
    {
      "name": "should handled quoted key and value",
      "statements": [
        "CREATE STREAM INPUT (`Key` STRING KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT `Key`, COUNT(1) AS `Value` FROM INPUT GROUP BY `Key`;"
      ],
      "inputs": [
        {"topic": "test_topic", "timestamp": 12345, "key": "11", "value": {}},
        {"topic": "test_topic", "timestamp": 12365, "key": "10", "value": {}},
        {"topic": "test_topic", "timestamp": 12375, "key": "11", "value": {}}
      ],
      "outputs": [
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "timestamp": 12345, "key": "11", "value": {"Key": "11", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "timestamp": 12365, "key": "10", "value": {"Key": "10", "KSQL_AGG_VARIABLE_0": 1}},
        {"topic": "_confluent-ksql-some.ksql.service.idquery_CTAS_OUTPUT_0-Aggregate-Aggregate-Materialize-changelog", "timestamp": 12375, "key": "11", "value": {"Key": "11", "KSQL_AGG_VARIABLE_0": 2}},
        {"topic": "OUTPUT", "key": "11", "value": {"Value": 1}},
        {"topic": "OUTPUT", "key": "10", "value": {"Value": 1}},
        {"topic": "OUTPUT", "key": "11", "value": {"Value": 2}}
      ],
      "post": {
        "sources": [
          {
            "name": "OUTPUT",
            "type": "table",
            "keyFormat": {"format": "KAFKA"},
            "schema": "`Key` STRING KEY, `Value` BIGINT"
          }
        ]
      }
    },
    {
      "name": "on join",
      "statements": [
        "CREATE TABLE t1 (ID BIGINT PRIMARY KEY, TOTAL integer) WITH (kafka_topic='T1', value_format='AVRO');",
        "CREATE TABLE t2 (ID BIGINT PRIMARY KEY, TOTAL integer) WITH (kafka_topic='T2', value_format='AVRO');",
        "CREATE TABLE OUTPUT AS SELECT t1.ID, SUM(t1.total + CASE WHEN t2.total IS NULL THEN 0 ELSE t2.total END) as SUM FROM T1 LEFT JOIN T2 ON (t1.ID = t2.ID) GROUP BY t1.ID HAVING COUNT(1) > 0;"
      ],
      "inputs": [
        {"topic": "T1", "key": 0, "value": {"total": 100}},
        {"topic": "T1", "key": 1, "value": {"total": 101}},
        {"topic": "T2", "key": 0, "value": {"total": 5}},
        {"topic": "T2", "key": 1, "value": {"total": 10}},
        {"topic": "T2", "key": 0, "value": {"total": 20}},
        {"topic": "T2", "key": 0, "value": null}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 0,"value": {"SUM": 100}},
        {"topic": "OUTPUT", "key": 1,"value": {"SUM": 101}},
        {"topic": "OUTPUT", "key": 0,"value": null},
        {"topic": "OUTPUT", "key": 0,"value": {"SUM": 105}},
        {"topic": "OUTPUT", "key": 1,"value": null},
        {"topic": "OUTPUT", "key": 1,"value": {"SUM": 111}},
        {"topic": "OUTPUT", "key": 0,"value": null},
        {"topic": "OUTPUT", "key": 0,"value": {"SUM": 120}},
        {"topic": "OUTPUT", "key": 0,"value": null},
        {"topic": "OUTPUT", "key": 0,"value": {"SUM": 100}}
      ]
    },
    {
      "name": "windowed join",
      "statements": [
        "CREATE TABLE A (id varchar primary key, regionid varchar) WITH (kafka_topic='a', value_format='json');",
        "CREATE STREAM B (id varchar) WITH (kafka_topic='b', value_format='json');",
        "CREATE TABLE test AS SELECT a.id, COUNT(*) as count FROM B LEFT JOIN A ON a.id = b.id WINDOW TUMBLING (SIZE 1 MINUTE) GROUP BY a.id HAVING COUNT(*) > 2;"
      ],
      "inputs": [
        {"topic": "a", "key": "1", "value": {"id": "1", "regionid": "one"}},
        {"topic": "b", "value": {"Id": "1"}},
        {"topic": "b", "value": {"Id": "1"}},
        {"topic": "b", "value": {"Id": "1"}}
      ],
      "outputs": [
        {"topic": "TEST", "key": "1", "value": null, "window": {"start": 0, "end": 60000, "type": "time"}},
        {"topic": "TEST", "key": "1", "value": null, "window": {"start": 0, "end": 60000, "type": "time"}},
        {"topic": "TEST", "key": "1", "value": {"COUNT": 3}, "window":  {"start": 0, "end": 60000, "type": "time"}}
      ]
    },
    {
      "name": "windowed join with window bounds",
      "tracked by": "https://github.com/confluentinc/ksql/issues/5931",
      "statements": [
        "CREATE STREAM A (ID VARCHAR, col1 VARCHAR) WITH (kafka_topic='a', value_format='JSON');",
        "CREATE TABLE B (ID VARCHAR PRIMARY KEY, col1 VARCHAR) WITH (kafka_topic='b', value_format='JSON');",
        "CREATE TABLE C AS SELECT A.ID, COUNT(*), WINDOWSTART as WSTART, WINDOWEND AS WEND FROM A JOIN B on A.ID = B.ID WINDOW TUMBLING (SIZE 10 MILLISECONDS) GROUP BY a.ID;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "SELECT column 'WINDOWSTART' cannot be resolved."
      }
    },
    {
      "name": "zero non-agg columns (stream)",
      "statements": [
        "CREATE STREAM INPUT (VALUE INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT as SELECT 1 as k, count(1) AS ID FROM INPUT group by 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"VALUE": 0}},
        {"topic": "test_topic", "value": {"VALUE": 0}},
        {"topic": "test_topic", "value": {"VALUE": 0}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 1}},
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 3}}
      ]
    },
    {
      "name": "zero non-agg columns (windowed stream)",
      "statements": [
        "CREATE STREAM INPUT (VALUE INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT as SELECT 1 as k, count(1) AS ID FROM INPUT WINDOW TUMBLING (SIZE 1 SECOND) group by 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"VALUE": 0}},
        {"topic": "test_topic", "value": {"VALUE": 0}},
        {"topic": "test_topic", "value": {"VALUE": 0}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"ID": 1}},
        {"topic": "OUTPUT", "key": 1, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": 1, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"ID": 3}}
      ]
    },
    {
      "name": "zero non-agg columns (table)",
      "statements": [
        "CREATE TABLE INPUT (ID INT PRIMARY KEY, VALUE INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT as SELECT 1 as k, count(1) AS ID FROM INPUT group by 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 10, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 1666, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 98, "value": {"VALUE": 0}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 1}},
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 3}}
      ]
    }
  ]
}