{
  "tests": [
    {
      "name": "only key column (stream->table)",
      "statements": [
        "CREATE STREAM INPUT (ID INT KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ID, COUNT(1) AS COUNT FROM INPUT GROUP BY ID;"
      ],
      "inputs": [
        {"topic": "test_topic", "timestamp": 12345, "key": 11, "value": {}},
        {"topic": "test_topic", "timestamp": 12365, "key": 10, "value": {}},
        {"topic": "test_topic", "timestamp": 12375, "key": 11, "value": {}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 11, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 10, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 11, "value": {"COUNT": 2}}
      ],
      "post": {
        "topics": {
          "blacklist": ".*-repartition"
        },
        "sources": [
          {
            "name": "OUTPUT",
            "type": "table",
            "keyFormat": {"format": "KAFKA"},
            "schema": "ID INT KEY, COUNT BIGINT"
          }
        ]
      }
    },
    {
      "name": "udafs only in having (stream->table)",
      "statements": [
        "CREATE STREAM INPUT (NAME STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT NAME, LEN(NAME) AS LEN FROM INPUT GROUP BY NAME HAVING COUNT(NAME) = 2;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"NAME": "bob"}, "timestamp": 1},
        {"topic": "test_topic", "value": {"NAME": "bob"}, "timestamp": 2},
        {"topic": "test_topic", "value": {"NAME": "bob"}, "timestamp": 3}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "bob", "value": {"LEN": 3}, "timestamp": 2},
        {"topic": "OUTPUT", "key": "bob", "value": null}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "keyFormat": {"format": "KAFKA"}, "schema": "NAME STRING KEY, LEN INT"}
        ]
      }
    },
    {
      "name": "all columns - repartition (stream->table)",
      "comment": "Currently, at least one value column is required...",
      "statements": [
        "CREATE STREAM INPUT (NAME STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT NAME FROM INPUT GROUP BY NAME HAVING COUNT(NAME) = 1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The projection contains no value columns."
      }
    },
    {
      "name": "all columns - no repartition (stream->table)",
      "comment": "Currently, at least one value column is required...",
      "statements": [
        "CREATE STREAM INPUT (NAME STRING KEY, V0 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT NAME FROM INPUT GROUP BY NAME HAVING COUNT(NAME) = 1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The projection contains no value columns."
      }
    },
    {
      "name": "value column (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA STRING KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "struct field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, ADDRESS STRUCT<STREET STRING, TOWN STRING>) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ADDRESS->TOWN, COUNT(*) AS COUNT FROM TEST GROUP BY ADDRESS->TOWN;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "Oxford"}}},
        {"topic": "test_topic", "key": 1, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "London"}}},
        {"topic": "test_topic", "key": 2, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "Oxford"}}},
        {"topic": "test_topic", "key": 3, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "London"}}},
        {"topic": "test_topic", "key": 4, "value": {"ADDRESS": {"STREET": "1st Steet", "Town": "Oxford"}}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "Oxford", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "London", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "Oxford", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "London", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "Oxford", "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "TOWN STRING KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, DATA STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT LEN(DATA), COUNT(*) AS COUNT FROM TEST GROUP BY LEN(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "22"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "333"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "-2"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "003"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "2-"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 INT KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single column with alias (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA AS NEW_KEY, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY STRING KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single column with alias (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA AS NEW_KEY, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d2", "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": "d1", "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY STRING KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single expression with alias (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT LEN(DATA) AS NEW_KEY, COUNT(*) AS COUNT FROM TEST GROUP BY LEN(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "22"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "333"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "-2"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "003"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "2-"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY INT KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "single expression with alias (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT LEN(DATA) AS NEW_KEY, COUNT(*) AS COUNT FROM TEST GROUP BY LEN(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "22"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "333"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "-2"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "003"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "2-"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 3, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY INT KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "steam with no key",
      "statements": [
        "CREATE STREAM TEST (data INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"data": 22}},
        {"topic": "test_topic", "value": {"data": 333}},
        {"topic": "test_topic", "value": {"data": 22}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 22, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 333, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 22, "value": {"COUNT": 2}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA INT KEY, COUNT BIGINT"}
        ]
      }
    },
    {
      "name": "subscript in group-by and select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, VARCHAR>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo'] AS NEW_KEY, COUNT(*) AS COUNT FROM INPUT GROUP BY col1['foo'];"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"foo" : "lala"}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"foo" : "kaka"}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"alice" : "wonderland"}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"mary" : "lamb"}}},
        {"topic": "test_topic", "key": 4, "value": {"col1": null}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "lala", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "kaka", "value": {"COUNT": 1}}
      ]
    },
    {
      "name": "subscript in group-by and having",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, VARCHAR>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo'] AS NEW_KEY, COUNT(*) AS COUNT FROM INPUT GROUP BY col1['foo'] HAVING col1['foo']='lala';"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"foo" : "lala"}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"foo" : "kaka"}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"alice" : "wonderland"}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"mary" : "lamb"}}},
        {"topic": "test_topic", "key": 4, "value": {"col1": null}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "lala", "value": {"COUNT": 1}}
      ]
    },
    {
      "name": "subscript in group-by and non aggregate function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, VARCHAR>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo'] AS NEW_KEY, AS_VALUE(col1['foo']) as VV, COUNT(*) AS COUNT FROM INPUT GROUP BY col1['foo'];"

      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"foo" : "lala"}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"foo" : "kaka"}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"alice" : "wonderland"}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"mary" : "lamb"}}},
        {"topic": "test_topic", "key": 4, "value": {"col1": null}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "lala", "value": {"VV": "lala","COUNT": 1}},
        {"topic": "OUTPUT", "key": "kaka", "value": {"VV": "kaka","COUNT": 1}}
      ]
    },
    {
      "name": "struct in group-by and non aggregate function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 STRUCT<a VARCHAR, b INT>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1->a AS NEW_KEY, AS_VALUE(col1->a) as VV, COUNT(*) AS COUNT FROM INPUT GROUP BY col1->a;"

      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"a" : "lala", "b": 1}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"a" : "lala", "b":  2}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"a" : "wonderland", "b": 3}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"a" : "lamb", "b": 4}}},
        {"topic": "test_topic", "key": 4, "value": {"col1": null}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "lala", "value": {"VV": "lala","COUNT": 1}},
        {"topic": "OUTPUT", "key": "lala", "value": {"VV": "lala","COUNT": 2}},
        {"topic": "OUTPUT", "key": "wonderland", "value": {"VV": "wonderland","COUNT": 1}},
        {"topic": "OUTPUT", "key": "lamb", "value": {"VV": "lamb","COUNT": 1}}
      ]
    },
    {
      "name": "function in group-by and nested function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 VARCHAR, col2 VARCHAR, col3 VARCHAR) WITH (kafka_topic='test_topic', format='json');",
        "CREATE TABLE OUTPUT AS SELECT INITCAP(COL1) AS G1, COL2 AS G2, TRIM(COL3) AS G3, concat(initcap(col1), col2, trim(col3)) AS foo, COUNT(*) FROM input GROUP BY INITCAP(col1), col2, TRIM(col3);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": "smells", "col2": "like", "col3": "teen spirit"}},
        {"topic": "test_topic", "key": 1, "value": {"col1": "the", "col2": "man who", "col3": "stole the world"}},
        {"topic": "test_topic", "key": 2, "value": {"col1": "smells", "col2": "like", "col3": "spring"}},
        {"topic": "test_topic", "key": 3, "value": {"col1": "smells", "col2": "like", "col3": "   teen spirit   "}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"G1": "Smells", "G2": "like", "G3": "teen spirit"}, "value": {"FOO": "Smellsliketeen spirit", "KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"G1": "The", "G2": "man who", "G3": "stole the world"}, "value": {"FOO": "Theman whostole the world", "KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"G1": "Smells", "G2": "like", "G3": "spring"}, "value": {"FOO": "Smellslikespring","KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"G1": "Smells", "G2": "like", "G3": "teen spirit"}, "value": {"FOO": "Smellsliketeen spirit","KSQL_COL_0": 2}}
      ]
    },
    {
      "name": "group by column in nested non-aggregate function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 VARCHAR, col2 VARCHAR, col3 VARCHAR) WITH (kafka_topic='test_topic', format='json');",
        "CREATE TABLE OUTPUT AS SELECT INITCAP(COL1) AS G1, COL2 AS G2, COL3 AS G3, concat(initcap(col1), col2, trim(col3)) AS foo, COUNT(*) FROM input GROUP BY INITCAP(col1), col2, col3;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": "smells", "col2": "like", "col3": "teen spirit"}},
        {"topic": "test_topic", "key": 1, "value": {"col1": "the", "col2": "man who", "col3": "stole the world"}},
        {"topic": "test_topic", "key": 2, "value": {"col1": "smells", "col2": "like", "col3": "spring"}},
        {"topic": "test_topic", "key": 3, "value": {"col1": "smells", "col2": "like", "col3": "   teen spirit   "}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"G1": "Smells", "G2": "like", "G3": "teen spirit"}, "value": {"FOO": "Smellsliketeen spirit", "KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"G1": "The", "G2": "man who", "G3": "stole the world"}, "value": {"FOO": "Theman whostole the world", "KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"G1": "Smells", "G2": "like", "G3": "spring"}, "value": {"FOO": "Smellslikespring","KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"G1": "Smells", "G2": "like", "G3": "   teen spirit   "}, "value": {"FOO": "Smellsliketeen spirit","KSQL_COL_0": 1}}
      ]
    },
    {
      "name": "function group by column used in non-aggregate function in having",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 VARCHAR, col2 VARCHAR, col3 VARCHAR) WITH (kafka_topic='test_topic', format='json');",
        "CREATE TABLE OUTPUT AS SELECT INITCAP(COL1) AS G1, COL2 AS G2, trim(COL3) AS G3, COUNT(*) FROM input GROUP BY INITCAP(col1), col2, trim(col3) HAVING substring(trim(col3),1,4) = 'teen';"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": "smells", "col2": "like", "col3": "teen spirit"}},
        {"topic": "test_topic", "key": 1, "value": {"col1": "the", "col2": "man who", "col3": "stole the world"}},
        {"topic": "test_topic", "key": 2, "value": {"col1": "smells", "col2": "like", "col3": "spring"}},
        {"topic": "test_topic", "key": 3, "value": {"col1": "smells", "col2": "like", "col3": "   teen spirit   "}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"G1": "Smells", "G2": "like", "G3": "teen spirit"}, "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"G1": "Smells", "G2": "like", "G3": "teen spirit"}, "value": {"KSQL_COL_0": 2}}
      ]
    },
    {
      "name": "arithmetic in group by column used in non-aggregate function in select",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 INT, col2 INT) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1+col2 AS G1, AS_VALUE(col1+col2), COUNT(*) FROM input GROUP BY col1+col2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": 1, "col2": 1}},
        {"topic": "test_topic", "key": 1, "value": {"col1": 2, "col2": 2}},
        {"topic": "test_topic", "key": 2, "value": {"col1": 3, "col2": 3}},
        {"topic": "test_topic", "key": 3, "value": {"col1": 4, "col2": 4}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": {"KSQL_COL_0": 2, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": 4, "value": {"KSQL_COL_0": 4, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": 6, "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": 8, "value": {"KSQL_COL_0": 8, "KSQL_COL_1": 1}}
      ]
    },
    {
      "name": "expressions used in non-aggregate function in select whose children are not part of group-by",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, INT>, col2 MAP<VARCHAR, INT>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo']+col2['bar'] AS G1, AS_VALUE(col1['foo']+col2['bar']), COUNT(*) FROM input GROUP BY col1['foo']+col2['bar'];"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"col1": {"a" : 1}, "col2": {"b" : 1}}},
        {"topic": "test_topic", "key": 1, "value": {"col1": {"foo" : 1}, "col2": {"bar" : 1}}},
        {"topic": "test_topic", "key": 2, "value": {"col1": {"bar" : 1}, "col2": {"foo" : 1}}},
        {"topic": "test_topic", "key": 3, "value": {"col1": {"foo" : 1}, "col2": {"foo" : 1}}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": {"KSQL_COL_0": 2, "KSQL_COL_1": 1}}
      ]
    },
    {
      "name": "unknown function",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, WONT_FIND_ME(ID) FROM TEST GROUP BY DATA;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Can't find any functions with the name 'WONT_FIND_ME'"
      }
    },
    {
      "name": "unknown function - multi group by",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING, other STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, OTHER, WONT_FIND_ME(ID) FROM TEST GROUP BY DATA, OTHER;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Can't find any functions with the name 'WONT_FIND_ME'"
      }
    },
    {
      "name": "non-table udaf on table",
      "statements": [
        "CREATE TABLE INPUT (ID BIGINT PRIMARY KEY, F0 INT, F1 BIGINT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ID, LATEST_BY_OFFSET(F0), MIN(F1), MAX(F1) FROM INPUT GROUP BY ID;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The aggregation functions LATEST_BY_OFFSET, MIN and MAX cannot be applied to a table source, only to a stream source."
      }
    },
    {
      "name": "multiple expressions",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT f2, f1, f2+f1, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": null}},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": null, "value": {"f2": "1"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"F1": 1, "F2": 2}, "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 4}, "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": {"F1": 1, "F2": 2}, "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 4}, "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 1}, "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F1 INT KEY, F2 INT KEY, KSQL_COL_0 INT, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "multiple expressions with struct field and other expression",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT, address STRUCT<street STRING, town STRING>) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT address->town, f1, 2*f2+f1, COUNT(*), 2*f2 FROM TEST GROUP BY f1, address->town, 2*f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"f2": "2", "ADDRESS": {"STREET": "1st Street", "Town": "Oxford"}}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4", "ADDRESS": {"STREET": "1st Street", "Town": "London"}}},
        {"topic": "test_topic", "key": 1, "value": {"f2": "2", "ADDRESS": {"STREET": "1st Street", "Town": "Oxford"}}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4", "ADDRESS": {"STREET": "1st Street", "Town": "London"}}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "1", "ADDRESS": {"STREET": "1st Street", "Town": "Oxford"}}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"F1": 1, "TOWN": "Oxford", "KSQL_COL_2": 4}, "value": {"KSQL_COL_0": 5, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": {"F1": 2, "TOWN": "London", "KSQL_COL_2": 8}, "value": {"KSQL_COL_0": 10, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": {"F1": 1, "TOWN": "Oxford", "KSQL_COL_2": 4}, "value": {"KSQL_COL_0": 5, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "TOWN": "London", "KSQL_COL_2": 8}, "value": {"KSQL_COL_0": 10, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "TOWN": "Oxford", "KSQL_COL_2": 2}, "value": {"KSQL_COL_0": 4, "KSQL_COL_1": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F1 INT KEY, TOWN STRING KEY, KSQL_COL_2 INT KEY, KSQL_COL_0 INT, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "multiple expressions - KAFKA key format",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT f2, f1, f2+f1, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Key format does not support schema.\nformat: KAFKA\nschema: Persistence{columns=[`F1` INTEGER KEY, `F2` INTEGER KEY], features=[]}\nreason: The 'KAFKA' format only supports a single field. Got: [`F1` INTEGER KEY, `F2` INTEGER KEY]\nStatement: CREATE TABLE OUTPUT AS SELECT\n  TEST.F2 F2,\n  TEST.F1 F1,\n  (TEST.F2 + TEST.F1) KSQL_COL_0,\n  COUNT(*) KSQL_COL_1\nFROM TEST TEST\nGROUP BY TEST.F1, TEST.F2\nEMIT CHANGES"
      }
    },
    {
      "name": "multiple expressions - KAFKA to non-KAFKA key format",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT WITH (KEY_FORMAT='JSON') AS SELECT f2, f1, f2+f1, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": null}},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": null, "value": {"f2": "1"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"F1": 1, "F2": 2}, "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 4}, "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": {"F1": 1, "F2": 2}, "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 4}, "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 1}, "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F1 INT KEY, F2 INT KEY, KSQL_COL_0 INT, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "multiple expressions - KAFKA to struct key format",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', value_format='JSON', partitions=1);",
        "CREATE TABLE OUTPUT WITH (KEY_FORMAT='JSON') AS SELECT STRUCT(f1:=f1, f2:=f2) AS k, as_value(struct(f1:=f1, f2:=f2)) AS key, COUNT(*) AS total FROM TEST GROUP BY STRUCT(f1:=f1, f2:=f2);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": null}},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": null, "value": {"f2": "1"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"F1": 1, "F2": 2}, "value": {"KEY": {"F1":1,"F2":2}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 4}, "value": {"KEY": {"F1":2,"F2":4}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"F1": 1, "F2": null}, "value": {"KEY": {"F1":1,"F2":null}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"F1": null, "F2": 1}, "value": {"KEY": {"F1":null,"F2":1}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"F1": 1, "F2": 2}, "value": {"KEY": {"F1":1,"F2":2}, "TOTAL": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 4}, "value": {"KEY": {"F1":2,"F2":4}, "TOTAL": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 1}, "value": {"KEY": {"F1":2,"F2":1}, "TOTAL": 1}}
      ]
    },
    {
      "name": "multiple expressions - KAFKA to non-supported decimal key format",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 DECIMAL(2, 1)) WITH (kafka_topic='test_topic', value_format='JSON', partitions=1);",
        "CREATE TABLE OUTPUT AS SELECT f2 AS key, COUNT(*) AS total FROM TEST GROUP BY f2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Key format does not support schema.\nformat: KAFKA\nschema: Persistence{columns=[`KEY` DECIMAL(2, 1) KEY], features=[]}\nreason: The 'KAFKA' format does not support type 'DECIMAL'\nStatement: CREATE TABLE OUTPUT AS SELECT\n  TEST.F2 KEY,\n  COUNT(*) TOTAL\nFROM TEST TEST\nGROUP BY TEST.F2\nEMIT CHANGES"
      }
    },
    {
      "name": "multiple expressions - KAFKA to non-supported decimal key format with JSON format conversion",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 DECIMAL(2, 1)) WITH (kafka_topic='test_topic', value_format='JSON', partitions=1);",
        "CREATE TABLE OUTPUT WITH (KEY_FORMAT='JSON') AS SELECT f2 AS key, COUNT(*) AS total FROM TEST GROUP BY f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": null}},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": null, "value": {"f2": "1"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2.0, "value": {"TOTAL": 1}},
        {"topic": "OUTPUT", "key": 4.0, "value": {"TOTAL": 1}},
        {"topic": "OUTPUT", "key": 1.0, "value": {"TOTAL": 1}},
        {"topic": "OUTPUT", "key": 2.0, "value": {"TOTAL": 2}},
        {"topic": "OUTPUT", "key": 4.0, "value": {"TOTAL": 2}},
        {"topic": "OUTPUT", "key": 1.0, "value": {"TOTAL": 2}}
      ],
      "post": {
        "sources": [
          {
            "name": "OUTPUT",
            "type": "table",
            "keyFormat": {"format": "JSON"},
            "schema": "KEY DECIMAL(2, 1) KEY, TOTAL BIGINT"
          }
        ]
      }
    },
    {
      "name": "multiple expressions - KAFKA to non-supported decimal key format with favored explicit AVRO format conversion",
      "enabled": false,
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 DECIMAL(2, 1)) WITH (kafka_topic='test_topic', value_format='JSON', partitions=1);",
        "CREATE TABLE OUTPUT WITH (KEY_FORMAT='AVRO') AS SELECT f2 AS key, COUNT(*) AS total FROM TEST GROUP BY f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": null}},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": null, "value": {"f2": "1"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2.0, "value": {"TOTAL": 1}},
        {"topic": "OUTPUT", "key": 4.0, "value": {"TOTAL": 1}},
        {"topic": "OUTPUT", "key": 1.0, "value": {"TOTAL": 1}},
        {"topic": "OUTPUT", "key": 2.0, "value": {"TOTAL": 2}},
        {"topic": "OUTPUT", "key": 4.0, "value": {"TOTAL": 2}},
        {"topic": "OUTPUT", "key": 1.0, "value": {"TOTAL": 2}}
      ],
      "post": {
        "sources": [
          {
            "name": "OUTPUT",
            "type": "table",
            "keyFormat": {"format": "AVRO"},
            "schema": "KEY DECIMAL(2, 1) KEY, TOTAL BIGINT"
          }
        ]
      }
    },
    {
      "name": "JSON format to KAFKA key format with unsupported multiple column",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', key_format='JSON', value_format='JSON', partitions=1);",
        "CREATE TABLE OUTPUT WITH (KEY_FORMAT='KAFKA') AS SELECT f1 AS k1, f2 AS k2, COUNT(*) AS total FROM TEST GROUP BY f1, f2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Key format does not support schema.\nformat: KAFKA\nschema: Persistence{columns=[`K1` INTEGER KEY, `K2` INTEGER KEY], features=[]}\nreason: The 'KAFKA' format only supports a single field. Got: [`K1` INTEGER KEY, `K2` INTEGER KEY]\nStatement: CREATE TABLE OUTPUT WITH (KEY_FORMAT='KAFKA') AS SELECT\n  TEST.F1 K1,\n  TEST.F2 K2,\n  COUNT(*) TOTAL\nFROM TEST TEST\nGROUP BY TEST.F1, TEST.F2\nEMIT CHANGES"
      }
    },
    {
      "name": "multiple expressions - delimited key format to multi-column primitive format",
      "statements": [
        "CREATE STREAM TEST (f1 STRING KEY, f2 INT) WITH (kafka_topic='test_topic', key_format='DELIMITED', value_format='JSON', partitions=1);",
        "CREATE TABLE OUTPUT AS SELECT f1 AS k1, f2 AS k2, COUNT(*) AS total FROM TEST GROUP BY f1, f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "a", "value": {"f2": "2"}},
        {"topic": "test_topic", "key": "b", "value": {"f2": "4"}},
        {"topic": "test_topic", "key": "a", "value": {"f2": null}},
        {"topic": "test_topic", "key": "a", "value": null},
        {"topic": "test_topic", "key": null, "value": {"f2": "1"}},
        {"topic": "test_topic", "key": "a", "value": {"f2": "2"}},
        {"topic": "test_topic", "key": "b", "value": {"f2": "4"}},
        {"topic": "test_topic", "key": "b", "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key":"a,2", "value": {"TOTAL": 1}},
        {"topic": "OUTPUT", "key":"b,4", "value": {"TOTAL": 1}},
        {"topic": "OUTPUT", "key":"a,2", "value": {"TOTAL": 2}},
        {"topic": "OUTPUT", "key":"b,4", "value": {"TOTAL": 2}},
        {"topic": "OUTPUT", "key":"b,1", "value": {"TOTAL": 1}}
      ]
    },
    {
      "name": "multiple expressions - delimited key format to multi-column, non-primitive format",
      "statements": [
        "CREATE STREAM TEST (f1 STRING KEY, f2 INT) WITH (kafka_topic='test_topic', key_format='DELIMITED', value_format='JSON', partitions=1);",
        "CREATE TABLE OUTPUT WITH (KEY_FORMAT='JSON') AS SELECT STRUCT(f1:=f1, f2:=f2) AS k1, f1 as k2, as_value(struct(f1:=f1, f2:=f2)) AS key, COUNT(*) AS total FROM TEST GROUP BY STRUCT(f1:=f1, f2:=f2), f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "a", "value": {"f2": "2"}},
        {"topic": "test_topic", "key": "b", "value": {"f2": "4"}},
        {"topic": "test_topic", "key": "a", "value": {"f2": null}},
        {"topic": "test_topic", "key": "a", "value": null},
        {"topic": "test_topic", "key": null, "value": {"f2": "1"}},
        {"topic": "test_topic", "key": "a", "value": {"f2": "2"}},
        {"topic": "test_topic", "key": "b", "value": {"f2": "4"}},
        {"topic": "test_topic", "key": "b", "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"K1": {"F1": "a", "F2": 2}, "K2": "a"}, "value": {"KEY": {"F1":"a","F2":2}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"K1": {"F1": "b", "F2": 4}, "K2": "b"}, "value": {"KEY": {"F1":"b","F2":4}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"K1": {"F1": "a", "F2": null}, "K2": "a"}, "value": {"KEY": {"F1":"a","F2":null}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"K1": {"F1": "a", "F2": 2}, "K2": "a"}, "value": {"KEY": {"F1":"a","F2":2}, "TOTAL": 2}},
        {"topic": "OUTPUT", "key": {"K1": {"F1": "b", "F2": 4}, "K2": "b"}, "value": {"KEY": {"F1":"b","F2":4}, "TOTAL": 2}},
        {"topic": "OUTPUT", "key": {"K1": {"F1": "b", "F2": 1}, "K2": "b"}, "value": {"KEY": {"F1":"b","F2":1}, "TOTAL": 1}}
      ]
    },
    {
      "name": "multiple expressions - delimited key format to struct format",
      "statements": [
        "CREATE STREAM TEST (f1 STRING KEY, f2 INT) WITH (kafka_topic='test_topic', key_format='DELIMITED', value_format='JSON', partitions=1);",
        "CREATE TABLE OUTPUT WITH (KEY_FORMAT='JSON') AS SELECT STRUCT(f1:=f1, f2:=f2) AS k, as_value(struct(f1:=f1, f2:=f2)) AS key, COUNT(*) AS total FROM TEST GROUP BY STRUCT(f1:=f1, f2:=f2);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "a", "value": {"f2": "2"}},
        {"topic": "test_topic", "key": "b", "value": {"f2": "4"}},
        {"topic": "test_topic", "key": "a", "value": {"f2": null}},
        {"topic": "test_topic", "key": "a", "value": null},
        {"topic": "test_topic", "key": null, "value": {"f2": "1"}},
        {"topic": "test_topic", "key": "a", "value": {"f2": "2"}},
        {"topic": "test_topic", "key": "b", "value": {"f2": "4"}},
        {"topic": "test_topic", "key": "b", "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"F1": "a", "F2": 2}, "value": {"KEY": {"F1":"a","F2":2}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"F1": "b", "F2": 4}, "value": {"KEY": {"F1":"b","F2":4}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"F1": "a", "F2": null}, "value": {"KEY": {"F1":"a","F2":null}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"F1": null, "F2": 1}, "value": {"KEY": {"F1":null,"F2":1}, "TOTAL": 1}},
        {"topic": "OUTPUT", "key": {"F1": "a", "F2": 2}, "value": {"KEY": {"F1":"a","F2":2}, "TOTAL": 2}},
        {"topic": "OUTPUT", "key": {"F1": "b", "F2": 4}, "value": {"KEY": {"F1":"b","F2":4}, "TOTAL": 2}},
        {"topic": "OUTPUT", "key": {"F1": "b", "F2": 1}, "value": {"KEY": {"F1":"b","F2":1}, "TOTAL": 1}}
      ]
    },
    {
      "name": "multiple expressions - windowed",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT f2, f1, f2+f1, COUNT(*) FROM TEST WINDOW TUMBLING (SIZE 1 SECOND) GROUP BY f1, f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 1, "value": {"f2": "2"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "4"}},
        {"topic": "test_topic", "key": 2, "value": {"f2": "1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"F1": 1, "F2": 2}, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 4}, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": {"F1": 1, "F2": 2}, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 4}, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"KSQL_COL_0": 6, "KSQL_COL_1": 2}},
        {"topic": "OUTPUT", "key": {"F1": 2, "F2": 1}, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"KSQL_COL_0": 3, "KSQL_COL_1": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F1 INT KEY, F2 INT KEY, KSQL_COL_0 INT, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "multiple expressions - table aggregate",
      "statements": [
        "CREATE TABLE INPUT (ID INT PRIMARY KEY, VALUE INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT as SELECT 1 as k, value, count(1) AS ID FROM INPUT group by value, 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 10, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 1666, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 98, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 98, "value": {"VALUE": 1}},
        {"topic": "test_topic", "key": 2, "value": {"VALUE": null}},
        {"topic": "test_topic", "key": 2, "value": null}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"VALUE": 0, "K": 1}, "value": {"ID": 1}},
        {"topic": "OUTPUT", "key": {"VALUE": 0, "K": 1}, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": {"VALUE": 0, "K": 1}, "value": {"ID": 3}},
        {"topic": "OUTPUT", "key": {"VALUE": 0, "K": 1}, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": {"VALUE": 1, "K": 1}, "value": {"ID": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "VALUE INT KEY, K INT KEY, ID BIGINT"}
        ]
      }
    },
    {
      "name": "multiple expressions - table aggregate - KAFKA to non-KAFKA key format",
      "statements": [
        "CREATE TABLE INPUT (ID INT PRIMARY KEY, VALUE INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT WITH (KEY_FORMAT='JSON') as SELECT 1 as k, value, count(1) AS ID FROM INPUT group by value, 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 10, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 1666, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 98, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 98, "value": {"VALUE": 1}},
        {"topic": "test_topic", "key": 2, "value": {"VALUE": null}},
        {"topic": "test_topic", "key": 2, "value": null}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"VALUE": 0, "K": 1}, "value": {"ID": 1}},
        {"topic": "OUTPUT", "key": {"VALUE": 0, "K": 1}, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": {"VALUE": 0, "K": 1}, "value": {"ID": 3}},
        {"topic": "OUTPUT", "key": {"VALUE": 0, "K": 1}, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": {"VALUE": 1, "K": 1}, "value": {"ID": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "VALUE INT KEY, K INT KEY, ID BIGINT"}
        ]
      }
    },
    {
      "name": "single expression - key in projection more than once",
      "statements": [
        "CREATE STREAM INPUT (ID INT KEY, NAME STRING) WITH (kafka_topic='input',value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT NAME, NAME AS NAME2, COUNT(1) FROM INPUT GROUP BY NAME;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The projection contains a key column more than once: `NAME` and `NAME2`."
      }
    },
    {
      "name": "single expression - key missing from projection - with other column of same name",
      "statements": [
        "CREATE STREAM INPUT (ID INT KEY, NAME STRING) WITH (kafka_topic='input',value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(1) AS NAME FROM INPUT GROUP BY NAME;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The query used to build `OUTPUT` must include the grouping expression NAME in its projection (eg, SELECT NAME...)."
      }
    },
    {
      "name": "single expression - key missing from projection",
      "statements": [
        "CREATE STREAM INPUT (ID INT KEY, NAME STRING) WITH (kafka_topic='input',value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(1) FROM INPUT GROUP BY NAME;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The query used to build `OUTPUT` must include the grouping expression NAME in its projection (eg, SELECT NAME...)."
      }
    },
    {
      "name": "multiple expressions - single key missing from projection",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The query used to build `OUTPUT` must include the grouping expression F1 in its projection (eg, SELECT F1...)."
      }
    },
    {
      "name": "multiple expression - key in projection more than once",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, f1 AS F3, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The projection contains a key column more than once: `F1` and `F3`."
      }
    },
    {
      "name": "multiple expressions - all keys missing from projection",
      "statements": [
        "CREATE STREAM TEST (f1 INT KEY, f2 INT, f3 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY f1, f2, f3;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The query used to build `OUTPUT` must include the grouping expressions F1, F2 and F3 in its projection (eg, SELECT F1, F2, F3...)."
      }
    },
    {
      "name": "select * where all columns in group by",
      "statements": [
        "CREATE STREAM TEST (id INT KEY, id2 INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT *, COUNT() FROM TEST GROUP BY id, id2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"ID2": 2}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"ID": 1, "ID2": 2}, "value": {"KSQL_COL_0": 1}}
      ]
    },
    {
      "name": "select * where not all columns in group by",
      "statements": [
        "CREATE STREAM TEST (id INT KEY, id2 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT *, COUNT() FROM TEST GROUP BY id;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: ID2"
      }
    },
    {
      "name": "create table as select COUNT(*) with no group by",
      "statements": [
        "CREATE STREAM TEST (id INT KEY, id2 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "CREATE TABLE AS SELECT statement does not support aggregate function [COUNT(ROWTIME)] without a GROUP BY clause."
      }
    },
    {
      "name": "with key alias that clashes with value alias",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA AS COUNT, COUNT(*) AS COUNT FROM TEST GROUP BY DATA;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Duplicate value columns found in schema: `COUNT` BIGINT"
      }
    },
    {
      "name": "map used in non-aggregate function in select when group by uses subscript",
      "statements": [
        "CREATE STREAM INPUT (id INT KEY, col1 MAP<VARCHAR, VARCHAR>) WITH (kafka_topic='test_topic', value_format='json');",
        "CREATE TABLE OUTPUT AS SELECT col1['foo'], AS_VALUE(col1) AS foo, COUNT(*) FROM input GROUP BY col1['foo'];"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: AS_VALUE(COL1)\nEither add the column(s) to the GROUP BY or remove them from the SELECT."
      }
    },
    {
      "name": "complex UDAF params",
      "statements": [
        "CREATE STREAM TEST (V0 INT KEY, V1 INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT V0, V1, SUM(V0 + V1) AS SUM FROM TEST GROUP BY V0, V1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}},
        {"topic": "test_topic", "key": 1, "value": {"V1": 20}},
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"V0": 0, "V1": 10}, "value": {"SUM": 10}},
        {"topic": "OUTPUT", "key": {"V0": 1, "V1": 20}, "value": {"SUM": 21}},
        {"topic": "OUTPUT", "key": {"V0": 0, "V1": 10}, "value": {"SUM": 20}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "V0 INTEGER KEY, V1 INTEGER KEY, SUM INT"}
        ]
      }
    },
    {
      "name": "complex UDAF params matching GROUP BY",
      "statements": [
        "CREATE STREAM TEST (V0 INT KEY, V1 INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT (V0 + V1) AS NEW_KEY, SUM(V0 + V1) AS SUM FROM TEST GROUP BY V0 + V1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}},
        {"topic": "test_topic", "key": 1, "value": {"V1": 20}},
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 10, "value": {"SUM": 10}},
        {"topic": "OUTPUT", "key": 21, "value": {"SUM": 21}},
        {"topic": "OUTPUT", "key": 10, "value": {"SUM": 20}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "NEW_KEY INT KEY, SUM INT"}
        ]
      }
    },
    {
      "name": "complex UDAF params matching HAVING",
      "statements": [
        "CREATE STREAM TEST (V0 INT KEY, V1 INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT SUM(V0 + V1) AS SUM, V0, V1 FROM TEST GROUP BY V0, V1 HAVING V0 + V1 <= 20;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}},
        {"topic": "test_topic", "key": 1, "value": {"V1": 20}},
        {"topic": "test_topic", "key": 0, "value": {"V1": 10}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"V0": 0, "V1": 10}, "value": {"SUM": 10}},
        {"topic": "OUTPUT", "key": {"V0": 0, "V1": 10}, "value": {"SUM": 20}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "V0 INTEGER KEY, V1 INTEGER KEY, SUM INT"}
        ]
      }
    },
    {
      "name": "single expression with nulls",
      "comment": "bad_udf return every other invocation - tables need a PRIMARY key so null keys are dropped",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT bad_udf(DATA), COUNT(*) FROM TEST GROUP BY bad_udf(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_1": 2}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "complex expressions",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY DATA AND ID;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.parser.exception.ParseFailedException",
        "message": "Syntax Error"
      }
    },
    {
      "name": "multiple expressions with nulls",
      "comment": "bad_udf returns null every other invocation - tables need a PRIMARY key so null keys are dropped",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT bad_udf(DATA), COUNT(*) FROM TEST GROUP BY bad_udf(DATA);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 1, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 2, "value": {"data": "d1"}},
        {"topic": "test_topic", "key": 3, "value": {"data": "d2"}},
        {"topic": "test_topic", "key": 4, "value": {"data": "d1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_1": 1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_1": 2}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT K, COUNT(*) FROM TEST GROUP BY K;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "d1", "value": "-"},
        {"topic": "test_topic", "key": "d2", "value": "-"},
        {"topic": "test_topic", "key": "d1", "value": "-"},
        {"topic": "test_topic", "key": "d2", "value": "-"},
        {"topic": "test_topic", "key": "d1", "value": "-"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": "1"},
        {"topic": "OUTPUT", "key": "d2", "value": "1"},
        {"topic": "OUTPUT", "key": "d1", "value": "2"},
        {"topic": "OUTPUT", "key": "d2", "value": "2"},
        {"topic": "OUTPUT", "key": "d1", "value": "3"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "K STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "field (stream->table) - KAFKA",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='KAFKA');",
        "CREATE TABLE OUTPUT WITH(value_format='DELIMITED') AS SELECT DATA, COUNT(*) FROM TEST GROUP BY DATA;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Source(s) TEST are using the 'KAFKA' value format. This format does not yet support GROUP BY."
      }
    },
    {
      "name": "field (stream->table) - format",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='{FORMAT}');",
        "CREATE TABLE OUTPUT AS SELECT K, COUNT(*) FROM TEST GROUP BY K;"
      ],
      "format": ["AVRO", "JSON", "PROTOBUF"],
      "inputs": [
        {"topic": "test_topic", "key": "d1", "value": {}, "timestamp": 1},
        {"topic": "test_topic", "key": "d2", "value": {}, "timestamp": 2},
        {"topic": "test_topic", "key": "d1", "value": {}, "timestamp": 3},
        {"topic": "test_topic", "key": "d2", "value": {}, "timestamp": 4},
        {"topic": "test_topic", "key": "d1", "value": {}, "timestamp": 5}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":1}, "timestamp": 1},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0":1}, "timestamp": 2},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":2}, "timestamp": 3},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0":2}, "timestamp": 4},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":3}, "timestamp": 5}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "K STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "int field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ID INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ID, COUNT(*) FROM TEST GROUP BY ID;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "a", "value": {"ID": 1}, "timestamp": 1},
        {"topic": "test_topic", "key": "b", "value": {"ID": 2}, "timestamp": 2},
        {"topic": "test_topic", "key": "c", "value": {"ID": 1}, "timestamp": 3},
        {"topic": "test_topic", "key": "d", "value": {"ID": 2}, "timestamp": 4},
        {"topic": "test_topic", "key": "e", "value": {"ID": 1}, "timestamp": 5}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": {"KSQL_COL_0":1}, "timestamp": 1},
        {"topic": "OUTPUT", "key": 2, "value": {"KSQL_COL_0":1}, "timestamp": 2},
        {"topic": "OUTPUT", "key": 1, "value": {"KSQL_COL_0":2}, "timestamp": 3},
        {"topic": "OUTPUT", "key": 2, "value": {"KSQL_COL_0":2}, "timestamp": 4},
        {"topic": "OUTPUT", "key": 1, "value": {"KSQL_COL_0":3}, "timestamp": 5}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "ID INT KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,a"},
        {"topic": "test_topic", "key": "2", "value": "2,b"},
        {"topic": "test_topic", "key": "1", "value": "1,a"},
        {"topic": "test_topic", "key": "2", "value": "2,b"},
        {"topic": "test_topic", "key": "3", "value": "3,a"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a,1", "value": "1"},
        {"topic": "OUTPUT", "key": "b,2", "value": "1"},
        {"topic": "OUTPUT", "key": "a,1", "value": "2"},
        {"topic": "OUTPUT", "key": "b,2", "value": "2"},
        {"topic": "OUTPUT", "key": "a,3", "value": "1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F2 STRING KEY, F1 INTEGER KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields used in expression",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 INT) WITH (kafka_topic='test_topic', format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT F1, F2, f1 / f2, COUNT(*) FROM TEST GROUP BY f1, f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "4,2"},
        {"topic": "test_topic", "value": "9,3"},
        {"topic": "test_topic", "value": "9,3"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "4,2", "value": "2,1"},
        {"topic": "OUTPUT", "key": "9,3", "value": "3,1"},
        {"topic": "OUTPUT", "key": "9,3", "value": "3,2"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F1 INTEGER KEY, F2 INTEGER KEY, KSQL_COL_0 INTEGER, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "fields (stream->table) - format",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', key_format='JSON', value_format='{FORMAT}');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "format": ["AVRO", "JSON", "PROTOBUF"],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "a"}},
        {"topic": "test_topic", "key": 2, "value": {"F1": 2, "F2": "b"}},
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "a"}},
        {"topic": "test_topic", "key": 2, "value": {"F1": 2, "F2": "b"}},
        {"topic": "test_topic", "key": 3, "value": {"F1": 3, "F2": "a"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"F2": "a", "F1": 1}, "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"F2": "b", "F1": 2}, "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"F2": "a", "F1": 1}, "value": {"KSQL_COL_0": 2}},
        {"topic": "OUTPUT", "key": {"F2": "b", "F1": 2}, "value": {"KSQL_COL_0": 2}},
        {"topic": "OUTPUT", "key": {"F2": "a", "F1": 3}, "value": {"KSQL_COL_0": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F2 STRING KEY, F1 INTEGER KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "with groupings (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT, f2 VARCHAR, f3 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f3, (f2, f1);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.parser.exception.ParseFailedException",
        "message": "line 2:74: Syntax Error\nmissing ')' at ','"
      }
    },
    {
      "name": "duplicate expressions",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, data STRING) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY DATA, TEST.DATA;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Duplicate GROUP BY expression: TEST.DATA"
      }
    },
    {
      "name": "with single grouping set (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT, f2 VARCHAR, f3 INT) WITH (kafka_topic='test_topic', format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, f3, COUNT(*) FROM TEST GROUP BY (f3, f2, f1);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,a,-1"},
        {"topic": "test_topic", "key": "2", "value": "2,b,-2"},
        {"topic": "test_topic", "key": "1", "value": "1,a,-1"},
        {"topic": "test_topic", "key": "2", "value": "2,b,-2"},
        {"topic": "test_topic", "key": "3", "value": "3,a,-3"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "\"-1\",a,1", "value": "1"},
        {"topic": "OUTPUT", "key": "\"-2\",b,2", "value": "1"},
        {"topic": "OUTPUT", "key": "\"-1\",a,1", "value": "2"},
        {"topic": "OUTPUT", "key": "\"-2\",b,2", "value": "2"},
        {"topic": "OUTPUT", "key": "\"-3\",a,3", "value": "1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F3 INTEGER KEY, F2 STRING KEY, F1 INTEGER KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,a"},
        {"topic": "test_topic", "key": "2", "value": "2,b"},
        {"topic": "test_topic", "key": "1", "value": "1,b"},
        {"topic": "test_topic", "key": "2", "value": null},
        {"topic": "test_topic", "key": "1", "value": "1,a"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a,1", "value": "1"},
        {"topic": "OUTPUT", "key": "b,2", "value": "1"},
        {"topic": "OUTPUT", "key": "a,1", "value": "0"},
        {"topic": "OUTPUT", "key": "b,1", "value": "1"},
        {"topic": "OUTPUT", "key": "b,2", "value": "0"},
        {"topic": "OUTPUT", "key": "b,1", "value": "0"},
        {"topic": "OUTPUT", "key": "a,1", "value": "1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F2 STRING KEY, F1 INTEGER KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields - copied into value (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, AS_VALUE(f1) AS F3, AS_VALUE(F2) AS F4, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,a"},
        {"topic": "test_topic", "key": "2", "value": "2,b"},
        {"topic": "test_topic", "key": "1", "value": "1,b"},
        {"topic": "test_topic", "key": "2", "value": null},
        {"topic": "test_topic", "key": "1", "value": "1,a"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a,1", "value": "1,a,1"},
        {"topic": "OUTPUT", "key": "b,2", "value": "2,b,1"},
        {"topic": "OUTPUT", "key": "a,1", "value": "1,a,0"},
        {"topic": "OUTPUT", "key": "b,1", "value": "1,b,1"},
        {"topic": "OUTPUT", "key": "b,2", "value": "2,b,0"},
        {"topic": "OUTPUT", "key": "b,1", "value": "1,b,0"},
        {"topic": "OUTPUT", "key": "a,1", "value": "1,a,1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F2 STRING KEY, F1 INTEGER KEY, F3 INT, F4 STRING, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "fields (table->table) - format",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', key_format='JSON', value_format='{FORMAT}');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2, f1;"
      ],
      "format": ["AVRO", "JSON", "PROTOBUF"],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "a"}},
        {"topic": "test_topic", "key": 2, "value": {"F1": 2, "F2": "b"}},
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "b"}},
        {"topic": "test_topic", "key": 2, "value": null},
        {"topic": "test_topic", "key": 1, "value": {"F1": 1, "F2": "a"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"F2": "a", "F1": 1}, "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"F2": "b", "F1": 2}, "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"F2": "a", "F1": 1}, "value": {"KSQL_COL_0": 0}},
        {"topic": "OUTPUT", "key": {"F2": "b", "F1": 1}, "value": {"KSQL_COL_0": 1}},
        {"topic": "OUTPUT", "key": {"F2": "b", "F1": 2}, "value": {"KSQL_COL_0": 0}},
        {"topic": "OUTPUT", "key": {"F2": "b", "F1": 1}, "value": {"KSQL_COL_0": 0}},
        {"topic": "OUTPUT", "key": {"F2": "a", "F1": 1}, "value": {"KSQL_COL_0": 1}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "F2 STRING KEY, F1 INTEGER KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "field with re-key (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "d1"},
        {"topic": "test_topic", "value": "d2"},
        {"topic": "test_topic", "value": "d1"},
        {"topic": "test_topic", "value": "d2"},
        {"topic": "test_topic", "value": "d1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": "1"},
        {"topic": "OUTPUT", "key": "d2", "value": "1"},
        {"topic": "OUTPUT", "key": "d1", "value": "2"},
        {"topic": "OUTPUT", "key": "d2", "value": "2"},
        {"topic": "OUTPUT", "key": "d1", "value": "3"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "double field with re-key (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data double) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "0.1"},
        {"topic": "test_topic", "value": "0.2"},
        {"topic": "test_topic", "value": "0.1"},
        {"topic": "test_topic", "value": "0.2"},
        {"topic": "test_topic", "value": "0.1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 0.1, "value": "1"},
        {"topic": "OUTPUT", "key": 0.2, "value": "1"},
        {"topic": "OUTPUT", "key": 0.1, "value": "2"},
        {"topic": "OUTPUT", "key": 0.2, "value": "2"},
        {"topic": "OUTPUT", "key": 0.1, "value": "3"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA DOUBLE KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "field with re-key (stream->table) - format",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='{FORMAT}');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*) FROM TEST GROUP BY DATA;"
      ],
      "format": ["AVRO", "JSON", "PROTOBUF"],
      "inputs": [
        {"topic": "test_topic", "value": {"DATA": "d1"}},
        {"topic": "test_topic", "value": {"DATA": "d2"}},
        {"topic": "test_topic", "value": {"DATA": "d1"}},
        {"topic": "test_topic", "value": {"DATA": "d2"}},
        {"topic": "test_topic", "value": {"DATA": "d1"}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":1}},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0":1}},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":2}},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0":2}},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0":3}}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "field with re-key (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT region, COUNT(*) FROM TEST GROUP BY region;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,r0"},
        {"topic": "test_topic", "key": 2, "value": "2,r1"},
        {"topic": "test_topic", "key": 3, "value": "3,r0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,r0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0", "value": "1"},
        {"topic": "OUTPUT", "key": "r1", "value": "1"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"},
        {"topic": "OUTPUT", "key": "r0", "value": "1"},
        {"topic": "OUTPUT", "key": "r1", "value": "0"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "REGION STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "with aggregate arithmetic (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(*)*2 FROM TEST GROUP BY DATA;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "d1"},
        {"topic": "test_topic", "value": "d2"},
        {"topic": "test_topic", "value": "d1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": "2"},
        {"topic": "OUTPUT", "key": "d2", "value": "2"},
        {"topic": "OUTPUT", "key": "d1", "value": "4"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "DATA STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "with aggregate arithmetic (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT region, COUNT(*) * 2 FROM TEST GROUP BY region;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,r0"},
        {"topic": "test_topic", "key": 2, "value": "2,r1"},
        {"topic": "test_topic", "key": 3, "value": "3,r0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,r0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0", "value": "2"},
        {"topic": "OUTPUT", "key": "r1", "value": "2"},
        {"topic": "OUTPUT", "key": "r0", "value": "4"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"},
        {"topic": "OUTPUT", "key": "r1", "value": "0"},
        {"topic": "OUTPUT", "key": "r0", "value": "4"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "REGION STRING KEY, KSQL_COL_0 BIGINT"}
        ]
      }
    },
    {
      "name": "with aggregate arithmetic involving source field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ITEM INT, COST INT) WITH (kafka_topic='test_topic', format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT ITEM, COST, COST * COUNT() FROM TEST GROUP BY ITEM, COST;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "1,10"},
        {"topic": "test_topic", "value": "1,20"},
        {"topic": "test_topic", "value": "2,30"},
        {"topic": "test_topic", "value": "1,10"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "1,10", "value": "10"},
        {"topic": "OUTPUT", "key": "1,20", "value": "20"},
        {"topic": "OUTPUT", "key": "2,30", "value": "30"},
        {"topic": "OUTPUT", "key": "1,10", "value": "20"}
      ]
    },
    {
      "name": "with aggregate arithmetic involving source field (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f0 INT, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f0, f0 * SUM(f1) FROM TEST GROUP BY f0;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 2, "value": "2,10"},
        {"topic": "test_topic", "key": 2, "value": "2,20"},
        {"topic": "test_topic", "key": 2, "value": "2,30"},
        {"topic": "test_topic", "key": 2, "value": null}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": "20"},
        {"topic": "OUTPUT", "key": 2, "value": "0"},
        {"topic": "OUTPUT", "key": 2, "value": "40"},
        {"topic": "OUTPUT", "key": 2, "value": "0"},
        {"topic": "OUTPUT", "key": 2, "value": "60"},
        {"topic": "OUTPUT", "key": 2, "value": "0"}
      ]
    },
    {
      "name": "with aggregate arithmetic involving source field not in group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, f0 INT, f1 INT, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1 * SUM(f2) FROM TEST GROUP BY f0;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (F1 * SUM(F2))\nEither add the column(s) to the GROUP BY or remove them from the SELECT."
      }
    },
    {
      "name": "function (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, source VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(source, 0, 2), COUNT(*) FROM TEST GROUP BY SUBSTRING(source, 0, 2);"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "some string"},
        {"topic": "test_topic", "value": "another string"},
        {"topic": "test_topic", "value": "some string again"},
        {"topic": "test_topic", "value": "another string again"},
        {"topic": "test_topic", "value": "some other string"},
        {"topic": "test_topic", "value": "the final string"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "so", "value": "1"},
        {"topic": "OUTPUT", "key": "an", "value": "1"},
        {"topic": "OUTPUT", "key": "so", "value": "2"},
        {"topic": "OUTPUT", "key": "an", "value": "2"},
        {"topic": "OUTPUT", "key": "so", "value": "3"},
        {"topic": "OUTPUT", "key": "th", "value": "1"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "function (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(region, 7, 2), COUNT(*) FROM TEST GROUP BY SUBSTRING(region, 7, 2);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,prefixr0"},
        {"topic": "test_topic", "key": 2, "value": "2,prefixr1"},
        {"topic": "test_topic", "key": 3, "value": "3,prefixr0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,prefixr0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0", "value": "1"},
        {"topic": "OUTPUT", "key": "r1", "value": "1"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"},
        {"topic": "OUTPUT", "key": "r0", "value": "1"},
        {"topic": "OUTPUT", "key": "r1", "value": "0"},
        {"topic": "OUTPUT", "key": "r0", "value": "2"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 STRING KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "int function (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT LEN(region), COUNT(*) FROM TEST GROUP BY LEN(region);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "usa"},
        {"topic": "test_topic", "key": "2", "value": "eu"},
        {"topic": "test_topic", "key": "3", "value": "usa"},
        {"topic": "test_topic", "key": "1", "value": null},
        {"topic": "test_topic", "key": "2", "value": "usa"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 3, "value": "1"},
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 3, "value": "2"},
        {"topic": "OUTPUT", "key": 3, "value": "1"},
        {"topic": "OUTPUT", "key": 2, "value": "0"},
        {"topic": "OUTPUT", "key": 3, "value": "2"}
      ],
      "post": {
        "sources": [
          {"name": "OUTPUT", "type": "table", "schema": "KSQL_COL_0 INT KEY, KSQL_COL_1 BIGINT"}
        ]
      }
    },
    {
      "name": "function with select field that is a subset of group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, source VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(source, 0, 1) AS Thing, COUNT(*) FROM TEST GROUP BY SUBSTRING(source, 0, 2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBSTRING(SOURCE, 0, 1)"
      }
    },
    {
      "name": "function with select field that is a subset of group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(region, 7, 1), COUNT(*) FROM TEST GROUP BY SUBSTRING(region, 7, 2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBSTRING(REGION, 7, 1)"
      }
    },
    {
      "name": "function with select field that is a superset of group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, source VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(source, 0, 3), COUNT(*) FROM TEST GROUP BY SUBSTRING(source, 0, 2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBSTRING(SOURCE, 0, 3)"
      }
    },
    {
      "name": "function with select field that is a superset of group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (K INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(region, 7, 3), COUNT(*) FROM TEST GROUP BY SUBSTRING(region, 7, 2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBSTRING(REGION, 7, 3)"
      }
    },
    {
      "name": "function with having field that is a subset of group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, source VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(source, 0, 2) AS Thing, COUNT(*) FROM TEST GROUP BY SUBSTRING(source, 0, 2) HAVING LEN(source) < 2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate HAVING expression not part of GROUP BY: SOURCE"
      }
    },
    {
      "name": "json field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (data STRUCT<field VARCHAR>) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT data->field AS FIELD, COUNT(*) AS COUNT FROM TEST GROUP BY data->field;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"data": {"field": "Something"}}},
        {"topic": "test_topic", "value": {"data": {"field": "Something Else"}}},
        {"topic": "test_topic", "value": {"data": {}}},
        {"topic": "test_topic", "value": {"data": {"field": "Something"}}},
        {"topic": "test_topic", "value": {"data": {}}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "Something", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "Something Else", "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": "Something", "value": {"COUNT": 2}}
      ]
    },
    {
      "name": "int json field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (data STRUCT<field INT>) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT data->field, COUNT(*) AS COUNT FROM TEST GROUP BY data->field;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"data": {"field": 1}}},
        {"topic": "test_topic", "value": {"data": {"field": 2}}},
        {"topic": "test_topic", "value": {"data": {}}},
        {"topic": "test_topic", "value": {"data": {"field": 1}}},
        {"topic": "test_topic", "value": {"data": {}}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 2, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": 1, "value": {"COUNT": 2}}
      ]
    },
    {
      "name": "key (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT K, COUNT(*) FROM TEST GROUP BY K;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "-"},
        {"topic": "test_topic", "key": "2", "value": "-"},
        {"topic": "test_topic", "key": "1", "value": "-"},
        {"topic": "test_topic", "key": "2", "value": "-"},
        {"topic": "test_topic", "key": "1", "value": "-"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "1", "value": "1"},
        {"topic": "OUTPUT", "key": "2", "value": "1"},
        {"topic": "OUTPUT", "key": "1", "value": "2"},
        {"topic": "OUTPUT", "key": "2", "value": "2"},
        {"topic": "OUTPUT", "key": "1", "value": "3"}
      ],
      "post": {
        "topics": {
          "blacklist": ".*-repartition"
        }
      }
    },
    {
      "name": "ROWTIME (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT ROWTIME AS RT, COUNT(*) FROM TEST GROUP BY ROWTIME;"
      ],
      "inputs": [{"topic": "test_topic", "value": "-", "timestamp":  10}],
      "outputs": [{"topic": "OUTPUT", "key": 10, "value": "1", "timestamp":  10}]
    },
    {
      "name": "constant (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, ignored VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT 1, COUNT(*) FROM TEST GROUP BY 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "-"},
        {"topic": "test_topic", "value": "-"},
        {"topic": "test_topic", "value": "-"},
        {"topic": "test_topic", "value": "-"},
        {"topic": "test_topic", "value": "-"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 1, "value": "3"},
        {"topic": "OUTPUT", "key": 1, "value": "4"},
        {"topic": "OUTPUT", "key": 1, "value": "5"}
      ]
    },
    {
      "name": "constant (table->table)",
      "statements": [
        "CREATE TABLE TEST (K INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT 1, COUNT(*) FROM TEST GROUP BY 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,r0"},
        {"topic": "test_topic", "key": 2, "value": "2,r1"},
        {"topic": "test_topic", "key": 3, "value": "3,r0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,r0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 1, "value": "3"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"}
      ]
    },
    {
      "name": "field with field used in function in projection (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, SUBSTRING(f1, 0, 1), COUNT(*) FROM TEST GROUP BY f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "one"},
        {"topic": "test_topic", "value": "two"},
        {"topic": "test_topic", "value": "three"},
        {"topic": "test_topic", "value": "one"},
        {"topic": "test_topic", "value": "five"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "one", "value": "o,1"},
        {"topic": "OUTPUT", "key": "two", "value": "t,1"},
        {"topic": "OUTPUT", "key": "three", "value": "t,1"},
        {"topic": "OUTPUT", "key": "one", "value": "o,2"},
        {"topic": "OUTPUT", "key": "five", "value": "f,1"}
      ]
    },
    {
      "name": "field with field used in function in projection (table->table)",
      "statements": [
        "CREATE TABLE TEST (ID INT PRIMARY KEY, user INT, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT region, SUBSTRING(region, 2, 1), COUNT(*) FROM TEST GROUP BY region;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1,r0"},
        {"topic": "test_topic", "key": 2, "value": "2,r1"},
        {"topic": "test_topic", "key": 3, "value": "3,r0"},
        {"topic": "test_topic", "key": 1, "value": null},
        {"topic": "test_topic", "key": 2, "value": "2,r0"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0", "value": "0,1"},
        {"topic": "OUTPUT", "key": "r1", "value": "1,1"},
        {"topic": "OUTPUT", "key": "r0", "value": "0,2"},
        {"topic": "OUTPUT", "key": "r0", "value": "0,1"},
        {"topic": "OUTPUT", "key": "r1", "value": "1,0"},
        {"topic": "OUTPUT", "key": "r0", "value": "0,2"}
      ]
    },
    {
      "name": "string concat using + op (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 VARCHAR, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2 + f1, COUNT(*) FROM TEST GROUP BY f2 + f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "1,a"},
        {"topic": "test_topic", "value": "2,b"},
        {"topic": "test_topic", "value": "1,a"},
        {"topic": "test_topic", "value": "2,b"},
        {"topic": "test_topic", "value": "3,a"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a1", "value": "1"},
        {"topic": "OUTPUT", "key": "b2", "value": "1"},
        {"topic": "OUTPUT", "key": "a1", "value": "2"},
        {"topic": "OUTPUT", "key": "b2", "value": "2"},
        {"topic": "OUTPUT", "key": "a3", "value": "1"}
      ]
    },
    {
      "name": "string concat using + op (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, user INT, subregion VARCHAR, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT region + subregion, COUNT(*) FROM TEST GROUP BY region + subregion;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,a,r0"},
        {"topic": "test_topic", "key": "2", "value": "2,a,r1"},
        {"topic": "test_topic", "key": "3", "value": "3,a,r0"},
        {"topic": "test_topic", "key": "4", "value": "4,b,r0"},
        {"topic": "test_topic", "key": "1", "value": null},
        {"topic": "test_topic", "key": "2", "value": "2,a,r0"},
        {"topic": "test_topic", "key": "2", "value": "2,b,r1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "r0a", "value": "1"},
        {"topic": "OUTPUT", "key": "r1a", "value": "1"},
        {"topic": "OUTPUT", "key": "r0a", "value": "2"},
        {"topic": "OUTPUT", "key": "r0b", "value": "1"},
        {"topic": "OUTPUT", "key": "r0a", "value": "1"},
        {"topic": "OUTPUT", "key": "r1a", "value": "0"},
        {"topic": "OUTPUT", "key": "r0a", "value": "2"},
        {"topic": "OUTPUT", "key": "r0a", "value": "1"},
        {"topic": "OUTPUT", "key": "r1b", "value": "1"}
      ]
    },
    {
      "name": "string concat using + op with projection field in wrong order (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 VARCHAR, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1 + f2, COUNT(*) FROM TEST GROUP BY f2 + f1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (F1 + F2)"
      }
    },
    {
      "name": "string concat using + op with projection field in wrong order (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, user INT, subregion VARCHAR, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT subregion + region, COUNT(*) FROM TEST GROUP BY region + subregion;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (SUBREGION + REGION)"
      }
    },
    {
      "name": "string concat with separate fields in projection (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 VARCHAR, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, f2, COUNT(*) FROM TEST GROUP BY f2 + f1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: F1, F2"
      }
    },
    {
      "name": "string concat with separate fields in projection (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, user INT, subregion VARCHAR, region VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT subregion, region, COUNT(*) FROM TEST GROUP BY region + subregion;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: SUBREGION, REGION"
      }
    },
    {
      "name": "arithmetic binary expression with projection in-order & non-commutative group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2 - f1, COUNT(*) FROM TEST GROUP BY f2 - f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "1,2"},
        {"topic": "test_topic", "value": "2,3"},
        {"topic": "test_topic", "value": "2,4"},
        {"topic": "test_topic", "value": "6,8"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 2, "value": "2"}
      ]
    },
    {
      "name": "arithmetic binary expression with projection in-order & non-commutative group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, f0 INT, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f0 - f1, COUNT(*) FROM TEST GROUP BY f0 - f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,0"},
        {"topic": "test_topic", "key": "2", "value": "2,1"},
        {"topic": "test_topic", "key": "3", "value": "3,1"},
        {"topic": "test_topic", "key": "1", "value": null},
        {"topic": "test_topic", "key": "2", "value": "4,2"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "0"},
        {"topic": "OUTPUT", "key": 2, "value": "2"}
      ]
    },
    {
      "name": "arithmetic binary expression with projection out-of-order & non-commutative group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1 - f2, COUNT(*) FROM TEST GROUP BY f2 - f1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (F1 - F2)"
      }
    },
    {
      "name": "arithmetic binary expression with projection out-of-order & non-commutative group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, f0 INT, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1 - f0, COUNT(*) FROM TEST GROUP BY f0 - f1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: (F1 - F0)"
      }
    },
    {
      "name": "with having expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, COUNT(*) FROM TEST GROUP BY f1 HAVING SUM(f1) > 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1"},
        {"topic": "test_topic", "key": 2, "value": "2"},
        {"topic": "test_topic", "key": 1, "value": "1"},
        {"topic": "test_topic", "key": 2, "value": "2"},
        {"topic": "test_topic", "key": 3, "value": "3"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 2, "value": "2"},
        {"topic": "OUTPUT", "key": 3, "value": "1"}
      ]
    },
    {
      "name": "with having expression (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, f0 INT, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, SUM(f0) FROM TEST GROUP BY f1 HAVING COUNT(f1) > 0;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,0", "timestamp": 1},
        {"topic": "test_topic", "key": "2", "value": "2,1", "timestamp": 2},
        {"topic": "test_topic", "key": "1", "value": null, "timestamp": 3},
        {"topic": "test_topic", "key": "3", "value": "3,0", "timestamp": 4},
        {"topic": "test_topic", "key": "2", "value": "2,0", "timestamp": 5}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 0, "value": "1", "timestamp": 1},
        {"topic": "OUTPUT", "key": 1, "value": "2", "timestamp": 2},
        {"topic": "OUTPUT", "key": 0, "value": null, "timestamp": 3},
        {"topic": "OUTPUT", "key": 0, "value": "3", "timestamp": 4},
        {"topic": "OUTPUT", "key": 1, "value": null, "timestamp": 5},
        {"topic": "OUTPUT", "key": 0, "value": "5", "timestamp": 5}
      ]
    },
    {
      "name": "with multiple having expressions (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, COUNT(f1) FROM TEST GROUP BY f1 HAVING COUNT(f1) > 1 AND f1=1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "0", "value": "1,a"},
        {"topic": "test_topic", "key": "0", "value": "2,b"},
        {"topic": "test_topic", "key": "0", "value": "1,test"},
        {"topic": "test_topic", "key": "0", "value": "2,test"},
        {"topic": "test_topic", "key": "0", "value": "2,test"},
        {"topic": "test_topic", "key": "0", "value": "1,test"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "2"},
        {"topic": "OUTPUT", "key": 1, "value": "3"}
      ]
    },
    {
      "name": "with having expression on non-group-by field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2, COUNT(*) FROM TEST GROUP BY f2 HAVING SUM(f1) > 10;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "-", "value": "5,a"},
        {"topic": "test_topic", "key": "-", "value": "10,b"},
        {"topic": "test_topic", "key": "-", "value": "6,a"},
        {"topic": "test_topic", "key": "-", "value": "1,b"},
        {"topic": "test_topic", "key": "-", "value": "-1,a"},
        {"topic": "test_topic", "key": "-", "value": "1,a"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a", "value": "2"},
        {"topic": "OUTPUT", "key": "b", "value": "2"},
        {"topic": "OUTPUT", "key": "a", "value": null},
        {"topic": "OUTPUT", "key": "a", "value": "4"}
      ]
    },
    {
      "name": "with constant having (stream-table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f2, SUM(f1) FROM TEST GROUP BY f2 HAVING f2='test';"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "0", "value": "1,a"},
        {"topic": "test_topic", "key": "0", "value": "2,b"},
        {"topic": "test_topic", "key": "0", "value": "2,test"},
        {"topic": "test_topic", "key": "0", "value": "2,b"},
        {"topic": "test_topic", "key": "0", "value": "3,test"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "test", "value": "2"},
        {"topic": "OUTPUT", "key": "test", "value": "5"}
      ]
    },
    {
      "name": "with constants in the projection (stream->table)",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, f1 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f1, 'some constant' as f3, COUNT(f1) FROM TEST GROUP BY f1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 1, "value": "1"},
        {"topic": "test_topic", "key": 2, "value": "2"},
        {"topic": "test_topic", "key": 1, "value": "1"},
        {"topic": "test_topic", "key": 2, "value": "2"},
        {"topic": "test_topic", "key": 3, "value": "3"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": "some constant,1"},
        {"topic": "OUTPUT", "key": 2, "value": "some constant,1"},
        {"topic": "OUTPUT", "key": 1, "value": "some constant,2"},
        {"topic": "OUTPUT", "key": 2, "value": "some constant,2"},
        {"topic": "OUTPUT", "key": 3, "value": "some constant,1"}
      ]
    },
    {
      "name": "missing matching projection field (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT data, COUNT(*) FROM TEST GROUP BY data;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 1},
        {"topic": "test_topic", "value": {"DATA": "d2"}, "timestamp": 2},
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 3}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 1}, "timestamp": 1},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0": 1}, "timestamp": 2},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 2}, "timestamp": 3}
      ]
    },
    {
      "name": "missing matching projection field (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, f1 INT, f2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT F2, COUNT(*) FROM TEST GROUP BY f2;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "1,a"},
        {"topic": "test_topic", "key": "2", "value": "2,b"},
        {"topic": "test_topic", "key": "1", "value": "1,b"},
        {"topic": "test_topic", "key": "2", "value": null},
        {"topic": "test_topic", "key": "1", "value": "1,a"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "a", "value": "1"},
        {"topic": "OUTPUT", "key": "b", "value": "1"},
        {"topic": "OUTPUT", "key": "a", "value": "0"},
        {"topic": "OUTPUT", "key": "b", "value": "2"},
        {"topic": "OUTPUT", "key": "b", "value": "1"},
        {"topic": "OUTPUT", "key": "b", "value": "0"},
        {"topic": "OUTPUT", "key": "a", "value": "1"}
      ]
    },
    {
      "name": "duplicate fields (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(1), COUNT(*), AS_VALUE(DATA) AS COPY FROM TEST GROUP BY data;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 1},
        {"topic": "test_topic", "value": {"DATA": "d2"}, "timestamp": 2},
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 3}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 1, "KSQL_COL_1": 1, "COPY": "d1"}, "timestamp": 1},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0": 1, "KSQL_COL_1": 1, "COPY": "d2"}, "timestamp": 2},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 2, "KSQL_COL_1": 2, "COPY": "d1"}, "timestamp": 3}
      ]
    },
    {
      "name": "duplicate udafs (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, data VARCHAR) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT DATA, COUNT(1), COUNT(1) FROM TEST GROUP BY data;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 1},
        {"topic": "test_topic", "value": {"DATA": "d2"}, "timestamp": 2},
        {"topic": "test_topic", "value": {"DATA": "d1"}, "timestamp": 3}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 1, "KSQL_COL_1": 1}, "timestamp": 1},
        {"topic": "OUTPUT", "key": "d2", "value": {"KSQL_COL_0": 1, "KSQL_COL_1": 1}, "timestamp": 2},
        {"topic": "OUTPUT", "key": "d1", "value": {"KSQL_COL_0": 2, "KSQL_COL_1": 2}, "timestamp": 3}
      ]
    },
    {
      "name": "with non-aggregate projection field not in group by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, COUNT(*) FROM TEST GROUP BY d2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: D1"
      }
    },
    {
      "name": "with non-aggregate projection field not in group by (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, d1 VARCHAR, d2 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, COUNT(*) FROM TEST GROUP BY d2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: D1"
      }
    },
    {
      "name": "aggregate function (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY SUM(d2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "GROUP BY does not support aggregate functions: SUM is an aggregate function."
      }
    },
    {
      "name": "aggregate function nested in arithmetic (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY 1 + SUM(d2);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "GROUP BY does not support aggregate functions: SUM is an aggregate function."
      }
    },
    {
      "name": "aggregate function nested in UDF (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT COUNT(*) FROM TEST GROUP BY SUBSTRING(d1, SUM(d2), 1);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "GROUP BY does not support aggregate functions: SUM is an aggregate function."
      }
    },
    {
      "name": "without aggregate functions (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(d1, 1, 2) FROM TEST GROUP BY d2;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "GROUP BY requires aggregate functions in either the SELECT or HAVING clause."
      }
    },
    {
      "name": "without group-by (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR, d2 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, COUNT() FROM TEST;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Non-aggregate SELECT expression(s) not part of GROUP BY: D1"
      }
    },
    {
      "name": "UDAF nested in UDF in select expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT D1, SUBSTRING('Mr Bugalicious', CAST(COUNT(*) AS INT), 1) FROM TEST GROUP BY d1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "x"},
        {"topic": "test_topic", "value": "xxx"},
        {"topic": "test_topic", "value": "y"},
        {"topic": "test_topic", "value": "x"},
        {"topic": "test_topic", "value": "xxx"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "x", "value": "M"},
        {"topic": "OUTPUT", "key": "xxx", "value": "M"},
        {"topic": "OUTPUT", "key": "y", "value": "M"},
        {"topic": "OUTPUT", "key": "x", "value": "r"},
        {"topic": "OUTPUT", "key": "xxx", "value": "r"}
      ]
    },
    {
      "name": "UDAF nested in UDF in select expression (table->table)",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, d0 INT, d1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, SUBSTRING('Mr Bugalicious', CAST(COUNT(*) AS INT), 1) FROM TEST GROUP BY d1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "0", "value": "0,x"},
        {"topic": "test_topic", "key": "1", "value": "1,x"},
        {"topic": "test_topic", "key": "2", "value": "2,xxx"},
        {"topic": "test_topic", "key": "3", "value": "3,xxx"},
        {"topic": "test_topic", "key": "1", "value": null},
        {"topic": "test_topic", "key": "2", "value": "2,yy"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "x", "value": "M"},
        {"topic": "OUTPUT", "key": "x", "value": "r"},
        {"topic": "OUTPUT", "key": "xxx", "value": "M"},
        {"topic": "OUTPUT", "key": "xxx", "value": "r"},
        {"topic": "OUTPUT", "key": "x", "value": "M"},
        {"topic": "OUTPUT", "key": "xxx", "value": "M"},
        {"topic": "OUTPUT", "key": "yy", "value": "M"}
      ]
    },
    {
      "name": "UDF nested in UDAF in select expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT d1, SUM(LEN(d1)) FROM TEST GROUP BY d1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "x"},
        {"topic": "test_topic", "value": "xxx"},
        {"topic": "test_topic", "value": "y"},
        {"topic": "test_topic", "value": "x"},
        {"topic": "test_topic", "value": "xxx"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "x", "value": "1"},
        {"topic": "OUTPUT", "key": "xxx", "value": "3"},
        {"topic": "OUTPUT", "key": "y", "value": "1"},
        {"topic": "OUTPUT", "key": "x", "value": "2"},
        {"topic": "OUTPUT", "key": "xxx", "value": "6"}
      ]
    },
    {
      "name": "UDAF nested in UDAF in select expression (stream->table)",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, d1 VARCHAR) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUM(COUNT()) FROM TEST GROUP BY d1;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "Aggregate functions can not be nested: SUM(COUNT())"
      }
    },
    {
      "name": "should exclude any stream row whose single GROUP BY expression resolves to NULL",
      "comment": "Passing NULL as the POS to SUBSTRING should resolve to NULL without an exception",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, str STRING, pos INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(str, pos), COUNT() FROM TEST GROUP BY SUBSTRING(str, pos);"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "xx,1"},
        {"topic": "test_topic", "value": "x,"},
        {"topic": "test_topic", "value": "xx,1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "xx", "value": "1"},
        {"topic": "OUTPUT", "key": "xx", "value": "2"}
      ]
    },
    {
      "name": "should exclude any table row whose single GROUP BY expression resolves to NULL",
      "comment": "Passing NULL as the POS to SUBSTRING should resolve to NULL without an exception",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, str STRING, pos INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT SUBSTRING(str, pos), COUNT() FROM TEST GROUP BY SUBSTRING(str, pos);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "1", "value": "xx,1"},
        {"topic": "test_topic", "key": "2", "value": "x,"},
        {"topic": "test_topic", "key": "3", "value": "xx,1"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "xx", "value": "1"},
        {"topic": "OUTPUT", "key": "xx", "value": "2"}
      ]
    },
    {
      "name": "should exclude any stream row whose single GROUP BY expression throws",
      "statements": [
        "CREATE STREAM TEST (K STRING KEY, id INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT BAD_UDF(id), COUNT() FROM TEST GROUP BY BAD_UDF(id);"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "1"}
      ],
      "outputs": [
      ]
    },
    {
      "name": "should exclude any table row whose single GROUP BY expression throws",
      "statements": [
        "CREATE TABLE TEST (K STRING PRIMARY KEY, id INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT BAD_UDF(id), COUNT() FROM TEST GROUP BY BAD_UDF(id);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": "2", "value": "1"}
      ],
      "outputs": [
      ]
    },
    {
      "name": "by non-STRING key",
      "statements": [
        "CREATE STREAM INPUT (K STRING KEY, f0 INT) WITH (kafka_topic='test_topic', value_format='DELIMITED');",
        "CREATE TABLE OUTPUT AS SELECT f0, COUNT(1) FROM INPUT GROUP BY f0;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": "2"},
        {"topic": "test_topic", "value": "3"},
        {"topic": "test_topic", "value": "2"}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 2, "value": "1"},
        {"topic": "OUTPUT", "key": 3, "value": "1"},
        {"topic": "OUTPUT", "key": 2, "value": "2"}
      ],
      "post": {
        "sources": [
          {
            "name": "OUTPUT",
            "type": "table",
            "keyFormat": {"format": "KAFKA"},
            "schema": "F0 INTEGER KEY, KSQL_COL_0 BIGINT"
          }
        ]
      }
    },
    {
      "name": "should handled quoted key and value",
      "statements": [
        "CREATE STREAM INPUT (`Key` STRING KEY, IGNORED INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT `Key`, COUNT(1) AS `Value` FROM INPUT GROUP BY `Key`;"
      ],
      "inputs": [
        {"topic": "test_topic", "timestamp": 12345, "key": "11", "value": {}},
        {"topic": "test_topic", "timestamp": 12365, "key": "10", "value": {}},
        {"topic": "test_topic", "timestamp": 12375, "key": "11", "value": {}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": "11", "value": {"Value": 1}},
        {"topic": "OUTPUT", "key": "10", "value": {"Value": 1}},
        {"topic": "OUTPUT", "key": "11", "value": {"Value": 2}}
      ],
      "post": {
        "sources": [
          {
            "name": "OUTPUT",
            "type": "table",
            "keyFormat": {"format": "KAFKA"},
            "schema": "`Key` STRING KEY, `Value` BIGINT"
          }
        ]
      }
    },
    {
      "name": "on join",
      "statements": [
        "CREATE TABLE t1 (ID BIGINT PRIMARY KEY, TOTAL integer) WITH (kafka_topic='T1', value_format='AVRO');",
        "CREATE TABLE t2 (ID BIGINT PRIMARY KEY, TOTAL integer) WITH (kafka_topic='T2', value_format='AVRO');",
        "CREATE TABLE OUTPUT AS SELECT t1.ID, SUM(t1.total + CASE WHEN t2.total IS NULL THEN 0 ELSE t2.total END) as SUM FROM T1 LEFT JOIN T2 ON (t1.ID = t2.ID) GROUP BY t1.ID HAVING COUNT(1) > 0;"
      ],
      "inputs": [
        {"topic": "T1", "key": 0, "value": {"total": 100}},
        {"topic": "T1", "key": 1, "value": {"total": 101}},
        {"topic": "T2", "key": 0, "value": {"total": 5}},
        {"topic": "T2", "key": 1, "value": {"total": 10}},
        {"topic": "T2", "key": 0, "value": {"total": 20}},
        {"topic": "T2", "key": 0, "value": null}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 0,"value": {"SUM": 100}},
        {"topic": "OUTPUT", "key": 1,"value": {"SUM": 101}},
        {"topic": "OUTPUT", "key": 0,"value": null},
        {"topic": "OUTPUT", "key": 0,"value": {"SUM": 105}},
        {"topic": "OUTPUT", "key": 1,"value": null},
        {"topic": "OUTPUT", "key": 1,"value": {"SUM": 111}},
        {"topic": "OUTPUT", "key": 0,"value": null},
        {"topic": "OUTPUT", "key": 0,"value": {"SUM": 120}},
        {"topic": "OUTPUT", "key": 0,"value": null},
        {"topic": "OUTPUT", "key": 0,"value": {"SUM": 100}}
      ]
    },
    {
      "name": "windowed join",
      "statements": [
        "CREATE TABLE A (id varchar primary key, regionid varchar) WITH (kafka_topic='a', value_format='json');",
        "CREATE STREAM B (id varchar) WITH (kafka_topic='b', value_format='json');",
        "CREATE TABLE test AS SELECT a.id, COUNT(*) as count FROM B LEFT JOIN A ON a.id = b.id WINDOW TUMBLING (SIZE 1 MINUTE) GROUP BY a.id HAVING COUNT(*) > 2;"
      ],
      "inputs": [
        {"topic": "a", "key": "1", "value": {"id": "1", "regionid": "one"}},
        {"topic": "b", "value": {"Id": "1"}},
        {"topic": "b", "value": {"Id": "1"}},
        {"topic": "b", "value": {"Id": "1"}}
      ],
      "outputs": [
        {"topic": "TEST", "key": "1", "value": {"COUNT": 3}, "window":  {"start": 0, "end": 60000, "type": "time"}}
      ]
    },
    {
      "name": "windowed join with window bounds",
      "tracked by": "https://github.com/confluentinc/ksql/issues/5931",
      "statements": [
        "CREATE STREAM A (ID VARCHAR, col1 VARCHAR) WITH (kafka_topic='a', value_format='JSON');",
        "CREATE TABLE B (ID VARCHAR PRIMARY KEY, col1 VARCHAR) WITH (kafka_topic='b', value_format='JSON');",
        "CREATE TABLE C AS SELECT A.ID, COUNT(*), WINDOWSTART as WSTART, WINDOWEND AS WEND FROM A JOIN B on A.ID = B.ID WINDOW TUMBLING (SIZE 10 MILLISECONDS) GROUP BY a.ID;"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "SELECT column 'WINDOWSTART' cannot be resolved."
      }
    },
    {
      "name": "zero non-agg columns (stream)",
      "statements": [
        "CREATE STREAM INPUT (VALUE INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT as SELECT 1 as k, count(1) AS ID FROM INPUT group by 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"VALUE": 0}},
        {"topic": "test_topic", "value": {"VALUE": 0}},
        {"topic": "test_topic", "value": {"VALUE": 0}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 1}},
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 3}}
      ]
    },
    {
      "name": "zero non-agg columns (windowed stream)",
      "statements": [
        "CREATE STREAM INPUT (VALUE INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT as SELECT 1 as k, count(1) AS ID FROM INPUT WINDOW TUMBLING (SIZE 1 SECOND) group by 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "value": {"VALUE": 0}},
        {"topic": "test_topic", "value": {"VALUE": 0}},
        {"topic": "test_topic", "value": {"VALUE": 0}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"ID": 1}},
        {"topic": "OUTPUT", "key": 1, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": 1, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"ID": 3}}
      ]
    },
    {
      "name": "zero non-agg columns (table)",
      "statements": [
        "CREATE TABLE INPUT (ID INT PRIMARY KEY, VALUE INT) WITH (kafka_topic='test_topic', value_format='JSON');",
        "CREATE TABLE OUTPUT as SELECT 1 as k, count(1) AS ID FROM INPUT group by 1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 10, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 1666, "value": {"VALUE": 0}},
        {"topic": "test_topic", "key": 98, "value": {"VALUE": 0}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 1}},
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 2}},
        {"topic": "OUTPUT", "key": 1, "value": {"ID": 3}}
      ]
    },
    {
      "name": "windowed aggregate with struct key",
      "format": ["JSON", "AVRO"],
      "statements": [
        "CREATE STREAM INPUT (ID STRUCT<F1 INT, F2 INT> KEY, VAL INT) WITH (kafka_topic='test_topic', format='{FORMAT}');",
        "CREATE TABLE OUTPUT as SELECT ID, count(1) AS count FROM INPUT WINDOW TUMBLING (SIZE 1 SECOND) group by ID;"
      ],
      "inputs": [
        {"topic": "test_topic", "key":{"F1": 1, "F2": 1}, "value": {"VAL": 0}},
        {"topic": "test_topic", "key":{"F1": 1, "F2": 1}, "value": {"VAL": 0}},
        {"topic": "test_topic", "key":{"F1": 1, "F2": 1}, "value": {"VAL": 0}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key":{"F1": 1, "F2": 1}, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key":{"F1": 1, "F2": 1}, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key":{"F1": 1, "F2": 1}, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"COUNT": 3}}
      ]
    },
    {
      "name": "windowed aggregate with field within struct key",
      "statements": [
        "CREATE STREAM INPUT (ID STRUCT<F1 INT, F2 INT> KEY, VAL INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT as SELECT ID->F1, count(1) AS count FROM INPUT WINDOW TUMBLING (SIZE 1 SECOND) group by ID->F1;"
      ],
      "inputs": [
        {"topic": "test_topic", "key":{"F1": 1, "F2": 1}, "value": {"VAL": 0}},
        {"topic": "test_topic", "key":{"F1": 1, "F2": 1}, "value": {"VAL": 0}},
        {"topic": "test_topic", "key":{"F1": 1, "F2": 1}, "value": {"VAL": 0}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key":1, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key":1, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"COUNT": 2}},
        {"topic": "OUTPUT", "key":1, "window": {"start": 0, "end": 1000, "type": "time"}, "value": {"COUNT": 3}}
      ]
    },
    {
      "name": "non-KAFKA key format",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"VAL": true}},
        {"topic": "test_topic", "key": 1, "value": {"VAL": false}},
        {"topic": "test_topic", "key": 2, "value": {"VAL": true}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": true, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": false, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": true, "value": {"COUNT": 2}}
      ]
    },
    {
      "name": "AVRO primitive key",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');",
        "CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;"
      ],
      "topics": [
        {
          "name": "test_topic",
          "keySchema": {"type": "int"},
          "keyFormat": "AVRO",
          "valueSchema": {"name": "ignored", "type": "record", "fields": [{"name": "VAL", "type": "boolean"}]},
          "valueFormat": "AVRO"
        }
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"VAL": true}},
        {"topic": "test_topic", "key": 1, "value": {"VAL": false}},
        {"topic": "test_topic", "key": 2, "value": {"VAL": true}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": true, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": false, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": true, "value": {"COUNT": 2}}
      ],
      "post": {
        "sources": [
          {
            "comment": "unwrap singles is implicitly set on all key formats that support both wrapping and unwrapping, including AVRO",
            "name" : "OUTPUT",
            "type" : "TABLE",
            "schema" : "`VAL` BOOLEAN KEY, `COUNT` BIGINT",
            "keyFormat" : {
              "format" : "AVRO"
            },
            "valueFormat" : "AVRO",
            "keyFeatures" : [ "UNWRAP_SINGLES" ],
            "valueFeatures" : [ ]
          }
        ]
      }
    },
    {
      "name": "AVRO struct key group by primitive",
      "statements": [
        "CREATE STREAM TEST (ID STRUCT<F1 INT> KEY, VAL BOOLEAN) WITH (kafka_topic='test_topic', format='AVRO');",
        "CREATE TABLE OUTPUT AS SELECT VAL, COUNT() AS COUNT FROM TEST GROUP BY VAL;"
      ],
      "topics": [
        {
          "name": "test_topic",
          "keySchema": {"name": "key", "type": "record", "fields": [{"name": "F1", "type": ["null", "int"]}]},
          "keyFormat": "AVRO",
          "valueSchema": {"name": "ignored", "type": "record", "fields": [{"name": "VAL", "type": "boolean"}]},
          "valueFormat": "AVRO"
        }
      ],
      "inputs": [
        {"topic": "test_topic", "key": {"F1": 0}, "value": {"VAL": true}},
        {"topic": "test_topic", "key": {"F1": 0}, "value": {"VAL": false}},
        {"topic": "test_topic", "key": {"F1": 1}, "value": {"VAL": true}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": true, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": false, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": true, "value": {"COUNT": 2}}
      ],
      "post": {
        "sources": [
          {
            "comment": "unwrap singles is implicitly set on all key formats that support both wrapping and unwrapping, including AVRO",
            "name" : "OUTPUT",
            "type" : "TABLE",
            "schema" : "`VAL` BOOLEAN KEY, `COUNT` BIGINT",
            "keyFormat" : {
              "format" : "AVRO"
            },
            "valueFormat" : "AVRO",
            "keyFeatures" : [ "UNWRAP_SINGLES" ],
            "valueFeatures" : [ ]
          }
        ]
      }
    },
    {
      "name": "AVRO group by struct",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='AVRO');",
        "CREATE TABLE OUTPUT AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);"
      ],
      "topics": [
        {
          "name": "test_topic",
          "keySchema": {"type": "int"},
          "keyFormat": "AVRO",
          "valueSchema": {"name": "ignored", "type": "record", "fields": [{"name": "A", "type": "int"}, {"name": "B", "type": "int"}]},
          "valueFormat": "AVRO"
        }
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"A": 1, "B": 1}},
        {"topic": "test_topic", "key": 1, "value": {"A": 2, "B": 1}},
        {"topic": "test_topic", "key": 2, "value": {"A": 1, "B": 1}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"A": 1, "B": 1}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": {"A": 2, "B": 1}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": {"A": 1, "B": 1}, "value": {"COUNT": 2}}
      ],
      "post": {
        "sources": [
          {
            "comment": "unwrap singles is implicitly set on all key formats that support both wrapping and unwrapping, including AVRO",
            "name" : "OUTPUT",
            "type" : "TABLE",
            "schema" : "`ROWKEY` STRUCT<A INTEGER, B INTEGER> KEY, `COUNT` BIGINT",
            "keyFormat" : {
              "format" : "AVRO"
            },
            "valueFormat" : "AVRO",
            "keyFeatures" : [ "UNWRAP_SINGLES" ],
            "valueFeatures" : [ ]
          }
        ],
        "topics": {
          "topics": [
            {
              "name": "OUTPUT",
              "keyFormat" : { "format" : "AVRO", "features": ["UNWRAP_SINGLES"], "properties": {"fullSchemaName": "io.confluent.ksql.avro_schemas.OutputKey"} },
              "keySchema": {
                "type": "record",
                "name": "OutputKey",
                "namespace": "io.confluent.ksql.avro_schemas",
                "fields": [
                  { "name": "A", "type": [ "null", "int" ], "default": null },
                  { "name": "B", "type": [ "null", "int" ], "default": null }
                ],
                "connect.name" : "io.confluent.ksql.avro_schemas.OutputKey"
              },
              "valueFormat" : { "format" : "AVRO" },
              "valueSchema": {
                "type": "record",
                "name": "KsqlDataSourceSchema",
                "namespace": "io.confluent.ksql.avro_schemas",
                "fields": [
                  { "name": "COUNT", "type": [ "null", "long" ], "default": null }
                ],
                "connect.name" : "io.confluent.ksql.avro_schemas.KsqlDataSourceSchema"
              }
            }
          ]
        }
      }
    },
    {
      "name": "JSON group by array",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ARRAY[a, b] AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY ARRAY[A, B];"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"A": 1, "B": 1}},
        {"topic": "test_topic", "key": 1, "value": {"A": 2, "B": 1}},
        {"topic": "test_topic", "key": 2, "value": {"A": 1, "B": 1}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": [1, 1], "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": [2, 1], "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": [1, 1], "value": {"COUNT": 2}}
      ]
    },
    {
      "name": "JSON group by struct",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"A": 1, "B": 1}},
        {"topic": "test_topic", "key": 1, "value": {"A": 2, "B": 1}},
        {"topic": "test_topic", "key": 2, "value": {"A": 1, "B": 1}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"A": 1, "B": 1}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": {"A": 2, "B": 1}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": {"A": 1, "B": 1}, "value": {"COUNT": 2}}
      ]
    },
    {
      "name": "JSON group by struct convert key format",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT WITH (key_format='AVRO') AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);"
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"A": 1, "B": 1}},
        {"topic": "test_topic", "key": 1, "value": {"A": 2, "B": 1}},
        {"topic": "test_topic", "key": 2, "value": {"A": 1, "B": 1}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"A": 1, "B": 1}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": {"A": 2, "B": 1}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": {"A": 1, "B": 1}, "value": {"COUNT": 2}}
      ],
      "post": {
        "topics": {
          "topics": [
            {
              "name": "OUTPUT",
              "keyFormat" : { "format" : "AVRO", "features": ["UNWRAP_SINGLES"], "properties": {"fullSchemaName": "io.confluent.ksql.avro_schemas.OutputKey"} },
              "keySchema": {
                "type": "record",
                "name": "OutputKey",
                "namespace": "io.confluent.ksql.avro_schemas",
                "fields": [
                  { "name": "A", "type": [ "null", "int" ], "default": null },
                  { "name": "B", "type": [ "null", "int" ], "default": null }
                ],
                "connect.name" : "io.confluent.ksql.avro_schemas.OutputKey"
              },
              "valueFormat" : { "format" : "JSON" }
            }
          ]
        }
      }
    },
    {
      "name": "JSON group by struct convert to incompatible key format",
      "statements": [
        "CREATE STREAM TEST (ID INT KEY, A INT, B INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT WITH (key_format='DELIMITED') AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT() AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);"
      ],
      "expectedException": {
        "type": "io.confluent.ksql.util.KsqlStatementException",
        "message": "The 'DELIMITED' format does not support type 'STRUCT', column: `ROWKEY`"
      }
    },
    {
      "name": "Struct key used in aggregate expression",
      "statements": [
        "CREATE STREAM TEST (ID STRUCT<F1 INT> KEY, VAL INT) WITH (kafka_topic='test_topic', format='JSON');",
        "CREATE TABLE OUTPUT AS SELECT ID, SUM(ID->F1) AS sum FROM TEST GROUP BY ID;"
      ],
      "inputs": [
        {"topic": "test_topic", "key": {"F1": 1}, "value": {"VAL": 1}},
        {"topic": "test_topic", "key": {"F1": 1}, "value": {"VAL": 2}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"F1": 1}, "value": {"SUM": 1}},
        {"topic": "OUTPUT", "key": {"F1": 1}, "value": {"SUM": 2}}
      ]
    },
    {
      "name": "PROTOBUF schema and schema_id",
      "statements": [
        "CREATE STREAM SOURCE WITH (kafka_topic='source', format='PROTOBUF', KEY_SCHEMA_ID=100, KEY_SCHEMA_FULL_NAME='ProtobufKey2', VALUE_SCHEMA_ID=101, VALUE_SCHEMA_FULL_NAME='ProtobufValue2');",
        "CREATE TABLE OUT AS SELECT K, COUNT(*) AS COUNT FROM SOURCE GROUP BY K;"
      ],
      "topics": [
        {
          "name": "source",
          "keyFormat": "PROTOBUF",
          "keySchemaId": 100,
          "keySchema": "syntax = \"proto3\"; message ProtobufKey1 {uint32 k1 = 1;} message ProtobufKey2 {string K = 1;}",
          "valueFormat": "PROTOBUF",
          "valueSchemaId": 101,
          "valueSchema": "syntax = \"proto3\"; message ProtobufValue1 {float c1 = 1; uint32 c2 = 2;} message ProtobufValue2 {uint64 A = 1; string B = 2;}"
        }
      ],
      "inputs": [
        {"topic": "source", "key": {"K": "falcon"}, "value": {"A": 1230, "B": "falcon"}, "timestamp": 0},
        {"topic": "source", "key": {"K": "giraffe"}, "value": {"A": 4560, "B": "giraffe"}, "timestamp": 0},
        {"topic": "source", "key": {"K": "turtle"}, "value": {"A": 7890, "B": "turtle"}, "timestamp": 0},
        {"topic": "source", "key": {"K": "falcon"}, "value": {"A": 1250, "B": "falcon"}, "timestamp": 0}
      ],
      "outputs": [
        {"topic": "OUT", "key": {"K": "falcon"}, "value": {"COUNT": 1}, "timestamp": 0},
        {"topic": "OUT", "key": {"K": "giraffe"}, "value": {"COUNT": 1}, "timestamp": 0},
        {"topic": "OUT", "key": {"K": "turtle"}, "value": {"COUNT": 1}, "timestamp": 0},
        {"topic": "OUT", "key": {"K": "falcon"}, "value": {"COUNT": 2}, "timestamp": 0}
      ],
      "post": {
        "sources": [
          {
            "name": "OUT",
            "type": "table",
            "keyFormat": {"format": "PROTOBUF", "properties": {"unwrapPrimitives": "true"}},
            "schema": "K STRING KEY, COUNT BIGINT"
          }
        ]
      }
    },
    {
      "name": "AVRO schema and schema id",
      "statements": [
        "CREATE STREAM TEST WITH (kafka_topic='test_topic', format='AVRO', KEY_SCHEMA_ID=100, VALUE_SCHEMA_ID=101);",
        "CREATE TABLE OUTPUT AS SELECT STRUCT(a:=A, b:=B) AS ROWKEY, COUNT(*) AS COUNT FROM TEST GROUP BY STRUCT(a:=A, b:=B);"
      ],
      "topics": [
        {
          "name": "test_topic",
          "keySchema": {"type": "int"},
          "keySchemaId": 100,
          "keyFormat": "AVRO",
          "valueSchema": {"name": "ignored", "type": "record", "fields": [{"name": "A", "type": "int"}, {"name": "B", "type": "int"}]},
          "valueFormat": "AVRO",
          "valueSchemaId": 101
        }
      ],
      "inputs": [
        {"topic": "test_topic", "key": 0, "value": {"A": 1, "B": 1}},
        {"topic": "test_topic", "key": 1, "value": {"A": 2, "B": 1}},
        {"topic": "test_topic", "key": 2, "value": {"A": 1, "B": 1}}
      ],
      "outputs": [
        {"topic": "OUTPUT", "key": {"A": 1, "B": 1}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": {"A": 2, "B": 1}, "value": {"COUNT": 1}},
        {"topic": "OUTPUT", "key": {"A": 1, "B": 1}, "value": {"COUNT": 2}}
      ],
      "post": {
        "sources": [
          {
            "comment": "unwrap singles is implicitly set on all key formats that support both wrapping and unwrapping, including AVRO",
            "name" : "OUTPUT",
            "type" : "TABLE",
            "schema" : "`ROWKEY` STRUCT<A INTEGER, B INTEGER> KEY, `COUNT` BIGINT",
            "keyFormat" : {
              "format" : "AVRO"
            },
            "valueFormat" : "AVRO",
            "keyFeatures" : [ "UNWRAP_SINGLES" ],
            "valueFeatures" : [ ]
          }
        ]
      }
    }
  ]
}